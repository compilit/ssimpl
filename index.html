<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>SSIMPL Specification</title>

  <script class="remove">
    const respecConfig = {
      specStatus: "ED",                // Editor’s Draft
      shortName: "ssimpl",
      editors: [
        {
          name: "Bastiën G.A. Bonsel",
          url: "https://compilit.com",
        }
      ],
      github: "https://github.com/compilit/ssimpl",
      license: "w3c-software-doc",
      group: ["vc", "did", "webauthn"],
      profile: "publication",
      localBiblio: {
        "DID": {
          "title": "Decentralized Identifiers (DIDs) v1.0",
          "href": "https://www.w3.org/TR/did-core/",
        },
        "VC": {
          title: "Verifiable Credentials Data Model v2.0",
          href: "https://www.w3.org/TR/vc-data-model-2.0/",
        },
        "BIP32": {
          "title": "BIP32",
          "href": "https://en.bitcoin.it/wiki/BIP_0032",
        },
        "BIP39": {
          "title": "BIP39",
          "href": "https://en.bitcoin.it/wiki/BIP_0039",
        },
        "Multibase": {
          "title": "The Multibase Data Format",
          "href": "https://www.ietf.org/archive/id/draft-multiformats-multibase-07.html",
        }
      }
    };
  </script>

  <script src="https://www.w3.org/Tools/respec/respec-w3c" async></script>
</head>

<body>
<section id="abstract">
  <p>
    SSIMPL defines a self-sovereign identity framework backed by
    government-issued trust anchors and a peer-validated ledger.
  </p>
</section>

<section id="conformance"></section>

<section id="sotd"></section>

<hr/>

<section>
  <h1 id="introduction">Introduction</h1>

  <p>The internet has evolved rapidly, but with each iteration new challenges have emerged in protecting
    personal data. While legislation attempts to safeguard users’ rights, technical solutions are
    often necessary to prevent misuse and unauthorized access to sensitive information.</p>

  <p>Current authentication and authorization methods rely heavily on centralized providers. OpenID Connect
    flows and other single sign-on mechanisms place identity management in the hands of commercial
    services, which cannot always guarantee the trustworthiness or privacy of the credentials they issue.</p>

  <p>In contrast, physical-world identity verification relies on standardized, verifiable documents such
    as passports or driver’s licenses. Informal authorization uses signatures or initials, which provide
    contextually appropriate trust without centralized control. SSIMPL was designed to replicate these
    principles in the digital realm, providing self-sovereign, verifiable credentials while minimizing
    reliance on third-party intermediaries.</p>
</section>

<hr/>

<section>
  <h1 id="overview">Overview</h1>
  <p>The SSIMPL protocol defines a <strong>Self-Sovereign Identity &amp; Mondial Pseudonymous Ledger</strong> framework
    that allows
    individuals to maintain control over their digital identity while enabling verifiable credential issuance and
    revocation. It bridges physical trust anchors (e.g., ePassports) with digital identity systems, ensuring
    cryptographic
    verification without reliance on centralized authorities.</p>
  <p>SSIMPL addresses several key problems:</p>
  <ol>
    <li><strong>User control over digital identity</strong> – eliminating reliance on centralized identity providers.
    </li>
    <li><strong>Verification of identities</strong> – ensuring online credentials correspond to real individuals using
      cryptographic
      proofs.
    </li>
    <li><strong>Sharing of identity-related data</strong> - allowing secure and transparent sharing of data</li>
  </ol>
  <p>The protocol balances decentralization, peer authority, and optional server-assisted synchronization for efficiency
    and availability. Everything is made to be deterministic by default, so no authorities whatsoever are required
    except
    the one that signed the Trust Anchor (TA).</p>
  <h2 id="identity-trust-model">Identity Trust Model</h2>
  <p>SSIMPL identities are rooted in cryptographically verifiable credentials derived from <strong>Trust
    Anchors</strong>, such as
    government-issued ePassports. A valid wallet:</p>
  <ul>
    <li>MUST extract cryptographic material from a TA</li>
    <li>MUST perform an Active Authentication (AA) challenge.</li>
    <li>MUST derive a <strong>Verifiable Credential Root (<a href="#wallet-specification">VCR</a>)</strong> tied to the
      user’s DID, as
      defined in [[DID]].
    </li>
  </ul>
  <p>This ensures only owners of verifiable physical credentials can create valid DIDs.</p>
  <h3 id="considerations">Considerations</h3>
  <p>Identity is hard to verify by nature. Using a state-issued TA is not a perfect solution, but it's the best
    deterministic proof of (human) identity available at the moment.</p>
  <h2 id="levels-of-authentication">Levels of Authentication</h2>
  <ul>
    <li><strong>Level 0:</strong> DID confirms human ownership (bot detection).</li>
    <li><strong>Level 1:</strong> Level 0 + unverifiable attributes (e.g. the owners home address) requested via scope.
    </li>
    <li><strong>Level 2:</strong> Level 1 + verifiable credentials requested via scope.</li>
  </ul>
  <p>These different levels allow people to authenticate themselves on several levels, depending on the context. Say a
    person would like to order a product from a website. Using SSIMPL, the webshop could request a certain scope of
    credentials (like a shipping address). The owner of the identity could then approve or disapprove this request. This
    flow is very similar to Open ID Connect, except that there is no need for a 3rd party.</p>
  <h2 id="roles">Roles</h2>
  <ul>
    <li><strong>Identity</strong> The owner of the TA.</li>
    <li><strong>Wallet:</strong> The actual software responsible for encapsulating the owners TA.</li>
    <li><strong>Peers:</strong> Mobile devices with the Wallet installed.</li>
    <li><strong>Relay Peers:</strong> Servers that act both as Peers and distribution points, allowing other Peers to
      sync their ledger.
    </li>
  </ul>
</section>

<hr/>

<section>
  <h1 id="wallet-specification">Wallet Specification</h1>
  <p>The wallet is a Self-Sovereign means of identification that can be installed and bootstrapped entirely independent
    of
    any authority. It solely relies on cryptographic proof. This cryptographic proof is contained within the so-called
    VCR. The Verifiable Credential Root is a VC, as defined in [[VC]], necessary to link the signer of this VC to the
    related public key & DID.</p>
  <p>
  <p>The VCR can also be used as the root of a chain of VCs. This way it can, either explicitly or implicitly, verify
    association
    to other credentials further up in the chain.</p>
  <h2 id="wallet-requirements">Wallet Requirements</h2>
  <p>Wallets <strong>MUST</strong>:</p>
  <ul>
    <li>Extract cryptographic material from a Trust Anchor (TA).</li>
    <li>Support Active Authentication challenge verification.</li>
    <li>Derive BIP32 keypairs (as defined in [[BIP32]]), from the BIP39 mnemonic (as defined in [[BIP39]]).</li>
    <li>Present the BIP39 mnemonic to the owner. <i>Note: the BIP39 mnemonic should be stored redundantly, preferably
      offline.</i></note></li>
    <li>Store the master BIP32 keypair in a secure storage section of their device (e.g. Apple Keychain, Android
      Keystore).
    </li>
    <li>Sign and manage the VCR.</li>
    <li>Generate (BIP32 child) DIDs compliant with <code>did:key</code> for interoperability.</li>
    <li>Support JWT issuance and asymmetric key exchange.</li>
  </ul>
  <p>Wallets <strong>SHOULD</strong>:</p>
  <ul>
    <li>Encrypt credentials for local storage.</li>
    <li>Extract and store additional VCs such as DG11 for user
      convenience.
    </li>
    <li>Send their signed VCR to Relay Peers.</li>
  </ul>
  <h2 id="wallet-functionality">Wallet Functionality</h2>
  <ul>
    <li>Before any transaction, the Wallet MUST call either the Well-known Relay Peer, or one of it's known Relay Peers
      for the
      latest delta.
    </li>
    <li>If the Wallet is new, it must first be bootstrapped. Which means acquiring the full current Ledger. This is done
      by
      requesting delta's in chunks between epochs, starting with 0 (Unix Time). Until the Ledger is fully in place,
      the
      Wallet MUST NOT allow any transactions.
    </li>
    <li>Before any transaction, the Wallet MUST call either the Well-known Relay Peer, or one of it's known Relay Peers
      for the
      latest list of known Relay Peers.
    </li>
  </ul>

  <h2 id="wallet-security">Wallet Security</h2>
  <p>A SSIMPL Wallet has certain security scenario's that need to be addressed</p>
  <ul>
    <li><strong>The owners TA is lost/stolen</strong>: The owner MUST revoke their current DID - No transactions can
      take place until a new TA has been used to bootstrap.
    </li>
    <li><strong>The owners device is lost/stolen</strong>: The owner MUST use their BIP39 mnemonic to restore their
      Wallet on a new device, then the owner MUST revoke their current DID and reinitialize their wallet.
    </li>
    <li><strong>The owners BIP39 mnemonic is lost/stolen</strong>: The owner MUST revoke their current DID and
      reinitialize their wallet. This will result in a double entry in respect to the same TA. But the 'older' one will
      be automatically ignored.
    </li>
    <li><strong>The owners BIP39 mnemonic AND TA is lost/stolen</strong>: The owner MUST revoke their current DID
      (through Delegated Revocation) and reinitialize their wallet on a new device using a new TA.
    </li>
    <li><strong>⚠️The owners BIP39 mnemonic AND TA is lost/stolen AND Delegated Revocation hasn't been
      configured</strong>:
      There is currently no way to come back from this scenario. For 10 years since the VCR registration, a malicious
      actor could potentially impersonate the owner of the original Identity. SSIMPL implementations MUST therefore have
      a mandatory Delegated Revocation exchange flow.
    </li>
  </ul>

  <h2>Delegated Revocation</h2>
  <p>In order to mitigate the most dire scenario, SSIMPL
    offers a relatively straight-forward solution: two Peers (you and someone you trust, like a close relative) exchange a complete
    <a href="#signedobject-ledgerentryrevocation">LedgerEntryRevocation</a>. In case of emergency, either Peer can always revoke the other Peers DID. This is a two-sided solution of
    course: it provides a nice safety net, but also introduces another safety risk. For these kind of scenario's, there
    are rarely perfect solutions.</p>
  <p>To support Delegated Revocation, an extra (otherwise optional) field is present: taId. Which allows future deny-listing of the use taId (e.g. the document number of the passport)</p>

  <h2 id="activation-process-in-case-of-an-e-passport-">Example activation Process (in case of an ePassport)</h2>
  <ol>
    <li>User installs wallet.</li>
    <li>Wallet prompts for MRZ line.</li>
    <li>NFC scan and extraction of passport data.</li>
    <li>Creation of Verifiable Credential Root (VCR).</li>
    <li>BIP39 mnemonic generation (and presentation to the user).</li>
    <li>BIP32 keypair derivation and storage.</li>
    <li>Signing of the VCR.</li>
    <li>Submission of the VCR to a Relay Peer.</li>
  </ol>
</section>

<hr/>

<section>
  <h1 id="relay-peer-specification">Relay Peer Specification</h1>
  <p>The Relay Peer is a special kind of Peer in the sense that it is static and reachable over the internet on a fixed
    hostname. It acts like any other Peer, but it also adds a storage layer for the Ledger and serves as distribution
    point for the Ledger. All Relay Peers together form a subnetwork on which all other (mobile) Peers 'ride'.
    This is purely infrastructural to help communication between Peers. It doesn't give any special privileges or
    authorities to any of the Relay Peers and does therefore still fulfill all requirements to be called
    decentralized.</p>
  <h3 id="well-known-relay-peer">The well-known Relay Peer</h3>
  <p>In order to establish a stable network, there should always be one well-known Relay Peer, which allows another
    Relay Peer to find others within the network. It also serves as an entry point for freshly installed Wallets to
    bootstrap.</p>
  <h3 id="relay-peer-responsibilities">Relay Peer Responsibilities</h3>
  <ul>
    <li>Announce themselves to a known (or the well-known) Relay Peer.</li>
    <li>Receive, validate and store new LedgerEntries.</li>
    <li>Receive, validate and store new LedgerEntryRevocations.</li>
    <li>Providing and storing a list of known Relay Peers for discovery.</li>
    <li>Responding to registration attempts from new Relay Peers.</li>
    <li>Gossiping about active Relay Peers.</li>
  </ul>
  <h2 id="relay-peer-bootstrap-and-verification">Relay Peer Bootstrap and Verification</h2>
  <p>To enable deterministic network formation and secure onboarding of Relay Peers, the SSIMPL protocol defines a
    bootstrap
    and verification procedure.</p>
  <p>The first time a new Relay Peer is bootstrapped, it MUST make itself known to a known (or a well-known Relay Peer,
    e.g., <code>root.ssimpl.org</code>) to
    obtain the first list of known Relay Peers. This is a hard-coded node that allows the network to kickstart itself
    and to
    have zero knowledge upfront when adding a new Relay Peer.</p>
  <h3 id="relay-peer-registration">Relay Peer Registration</h3>
  <p>Upon first contact with the network, a new Relay Peer:</p>
  <ol>
    <li>Contacts the Well-known Relay Peer (or another known Relay Peer) to announce its presence.</li>
    <li>Provides its signed DID using the canonical <strong>SignatureEnvelope</strong> format.</li>
    <li>Receives information about other Relay Peers in the network for further connections.</li>
    <li>Requests delta's from one (or more) of the Relay Peers in the network in chunks based on the time between
      two epochs.
      Starting with 0 (Unix Time) if it has never been online and otherwise starting with the epoch it was last online.
    </li>
  </ol>

</section>

<hr/>

<section>
  <h1 id="ledger-specification">Ledger Specification</h1>
  <p>The SSIMPL ledger is a <strong>deterministically canonical, peer-replicated structure</strong> tracking valid DIDs,
    maintained across
    Peers and Relay Peers.</p>
  <h2 id="goals">Goals</h2>
  <ul>
    <li>Track valid DIDs without a central authority.</li>
    <li>Support bounded state and deterministic pruning.</li>
    <li>Enable single-peer verification.</li>
    <li>Eventual consistency via optional gossip or client/server synchronization.</li>
    <li>Mobile-friendly operation for large ledgers (5–30 GB).</li>
  </ul>
  <h2 id="state-and-canonical-construction">State and Canonical Construction</h2>
  <ol>
    <li>Filter expired entries based on <code>did_expiry</code> and <code>GRACE_PERIOD</code>.</li>
    <li>Normalize entries into canonical byte format.</li>
    <li>Sort lexicographically by <code>did_expiry</code> then by <code>hash(did)</code>.</li>
    <li>Compute <code>root_hash</code> using a <strong>Merkle tree</strong> over the current, complete, pruned ledger.
    </li>
  </ol>
  <h2 id="merkle-tree">Merkle Tree</h2>
  <p>The SSIMPL ledger uses a <strong>Merkle tree</strong> to enable efficient verification of ledger state and
    individual entries.</p>
  <h3 id="mt-structure">Structure</h3>
  <ul>
    <li><strong>Leaves:</strong> Hashes of canonical ledger entries.</li>
    <li><strong>Branches:</strong> Hashes of concatenated child nodes.</li>
    <li><strong>Root:</strong> <code>root_hash</code> representing the current canonical ledger state.</li>
  </ul>
  <h3 id="updates">Updates</h3>
  <ol>
    <li>New ledger entries are appended as leaves.</li>
    <li>The affected branches are rehashed up to the root.</li>
    <li>Pruning does not delete nodes; the canonical ledger for the current epoch defines which entries are considered
      valid.
    </li>
  </ol>
  <h3 id="merkle-proofs">Merkle Proofs</h3>
  <ul>
    <li>To prove inclusion of a DID <code>xyz</code>, a peer can provide the leaf hash and the branch hashes up to
      <code>root_hash</code>.
    </li>
    <li>Other peers can recompute the root from the proof and verify it matches the canonical <code>root_hash</code>.
    </li>
  </ul>
  <h3 id="relation-to-checkpoints">Relation to Checkpoints</h3>
  <ul>
    <li>Checkpoints store a <code>root_hash</code> for a specific epoch.</li>
    <li>Peers can verify their ledger or deltas by starting from the latest checkpoint and applying updates.</li>
  </ul>
  <h2 id="validation-rules">Validation Rules</h2>
  <p>An entry is valid if:</p>
  <ol>
    <li><code>current_time</code> &lt; <code>did_expiry</code> + <code>GRACE_PERIOD</code>.</li>
    <li><code>hash(verifiable_credential_root.data)</code> equals <code>verifiable_credential_root.signature_document.message</code>.
    </li>
    <li>The public key in the DID matches <code>signature_document.signature.public_key</code>.</li>
    <li>Signature verification succeeds:
      <code>verify_signature(
        verifiable_credential_root.signature_document.message,
        verifiable_credential_root.signature_document.signature.value,
        verifiable_credential_root.signature_document.signature.public_key,
        verifiable_credential_root.signature_document.signature.algorithm
        )</code></li>
  </ol>
  <p>Expired or invalid entries are ignored and removed during canonical construction.</p>
  <h2 id="pruning-and-mutability">Pruning and Mutability</h2>
  <ul>
    <li><p>Peers <strong>MAY</strong> remove their own entries and expired entries. To revoke a DID:</p>
      <ol>
        <li>Store a revocation payload on the local Ledger.</li>
        <li>Store and submit a revocation payload to (Relay) Peers.</li>
      </ol>
    </li>
    <li><p>Peers <strong>MUST NOT</strong> remove valid entries or modify others' entries.</p>
    </li>
    <li>Deterministic pruning ensures consistent ledger state across peers.</li>
  </ul>
  <h2 id="synchronization">Synchronization</h2>
  <ul>
    <li>Peers exchange <code>{ epoch, root_hash }</code> metadata.</li>
    <li><strong>Matching hash:</strong> No action required.</li>
    <li><strong>Hash mismatch:</strong> Request missing entries or snapshots.</li>
    <li>Iterative delta exchange ensures eventual convergence.</li>
    <li>Relay Peers act as distribution points while also validating entries.</li>
    <li>Stateless Relay Peers may bootstrap from peers but should persist data for efficiency.</li>
  </ul>
  <h2 id="merkle-checkpoints">Merkle Checkpoints</h2>
  <p>To enable efficient verification of ledger history and prevent forks from propagating, the SSIMPL protocol
    introduces
    Merkle checkpoints. These checkpoints allow peers to validate that their current ledger state stems from a
    previously
    agreed-upon canonical state.</p>
  <h3 id="definition">Definition</h3>
  <p>A Merkle checkpoint is a snapshot of the canonical ledger at a given epoch, containing:</p>
  <ul>
    <li>epoch — The deterministic epoch number of the snapshot</li>
    <li>root_hash — The canonical ledger Merkle root at that epoch</li>
    <li>metadata (optional) — Any additional information, such as total entry count, checkpoint creator DID, or a
      reference
      timestamp
    </li>
  </ul>
  <h3 id="purpose">Purpose</h3>
  <p>Merkle checkpoints serve three main purposes:</p>
  <ol>
    <li>Anchoring history — They provide a trusted reference point for peers to verify that their current ledger is an
      extension of a previous canonical state.
    </li>
    <li>Fork detection — Peers can detect divergence by comparing their checkpointed root hash with peers’ reported
      checkpoints.
    </li>
    <li>Efficient synchronization — When a peer joins the network or recovers from offline mode, it can request deltas
      starting from the latest known checkpoint rather than from the genesis ledger.
    </li>
  </ol>
  <h3 id="creation-and-storage">Creation and Storage</h3>
  <ul>
    <li>Peers MAY create checkpoints at deterministic intervals (e.g., end of each epoch).</li>
    <li>Relay Peers SHOULD store checkpoints for availability, enabling efficient delta requests for mobile peers.</li>
    <li>Checkpoints themselves are immutable; once created, they cannot be modified or deleted.</li>
  </ul>
  <h3 id="verification">Verification</h3>
  <p>To verify a ledger using a checkpoint:</p>
  <ol>
    <li>Obtain the checkpoint for the target epoch (epoch, root_hash).</li>
    <li>Compute the canonical ledger state from the checkpoint epoch to the current state.</li>
    <li>Recompute the Merkle root for the resulting ledger.</li>
    <li>Confirm that the recomputed root matches the current root_hash.</li>
  </ol>
  <p>A mismatch indicates ledger tampering or divergence, and the peer MUST reject the inconsistent entries.</p>
  <h3 id="pruning-and-expiry">Pruning and Expiry</h3>
  <ul>
    <li>Checkpoints older than a configurable retention window MAY be pruned to reduce storage overhead.</li>
    <li>Retention policies SHOULD be deterministic and consistent across peers to maintain canonical verification
      paths.
    </li>
  </ul>
  <h3 id="security-considerations">Security Considerations</h3>
  <ul>
    <li>Checkpoint integrity — Checkpoints must be signed by the creating peer using their DID key.</li>
    <li>Fork prevention — Peers must reject any checkpoint that does not extend a known valid previous checkpoint.</li>
    <li>Replay attacks — Timestamps and epoch numbers help prevent replay of stale checkpoints.</li>
  </ul>
  <h2 id="security-properties">Security Properties</h2>
  <ul>
    <li>Single-peer revocation verification.</li>
    <li>Privacy-preserving registration.</li>
    <li>Resistance to illegal pruning and tampering.</li>
    <li>Bounded state growth.</li>
    <li>Eventual convergence under client/server synchronization.</li>
  </ul>

</section>

<hr/>

<section>
  <h1 id="conclusion">Conclusion</h1>
  <p>SSIMPL provides a <strong>self-sovereign identity framework</strong> with a deterministic, peer-validated ledger,
    enabling secure,
    verifiable DIDs anchored in government-issued credentials.</p>
  <p>All entries and operations are <strong>canonical, rule-derived, and independently verifiable by peers</strong>,
    ensuring a fully
    trustworthy and decentralized identity ecosystem.</p>
</section>

<hr/>

<section>
  <h2 id="canonicalization-rules">Canonicalization Rules</h2>
  <p>To ensure that signatures are verifiable and consistent across all peers, every signed object in SSIMPL (including
    LedgerEntry and VerifiableCredentialRoot) MUST be serialized in a canonical form before hashing and signing. These
    rules
    remove ambiguity in encoding and field ordering, preventing mismatches between peers.</p>
  <h2 id="object-serialization">Object Serialization</h2>
  <ol>
    <li>Field Ordering
      <ul>
        <li>All objects MUST have their fields sorted lexicographically by key name.</li>
        <li>Example: For {&quot;b&quot;:2,&quot;a&quot;:1}, canonical form is {&quot;a&quot;:1,&quot;b&quot;:2}.</li>
      </ul>
    </li>
    <li>Whitespace
      <ul>
        <li>No unnecessary whitespace is allowed.</li>
        <li>Only minimal separators required by the serialization format are permitted.</li>
      </ul>
    </li>
    <li>Encoding
      <ul>
        <li>All strings MUST be UTF-8 encoded.</li>
        <li>No BOM (Byte Order Mark) or non-standard characters are allowed.</li>
      </ul>
    </li>
    <li>Number Representation
      <ul>
        <li>Numbers MUST be represented without leading zeros (except zero itself) and without exponential notation.
        </li>
        <li>Example: 1.0 → 1.0; 01 → invalid.</li>
      </ul>
    </li>
    <li><p>Boolean and Null</p>
    </li>
    <li><p>true, false, and null MUST use JSON literals exactly as shown (case-sensitive).</p>
    </li>
  </ol>
  <h2 id="nested-objects">Nested Objects</h2>
  <ul>
    <li>Recursion: Apply canonicalization rules recursively to all nested objects and arrays.</li>
    <li>Arrays MUST preserve element order.</li>
    <li>Elements MUST themselves be canonicalized if they are objects or arrays.</li>
  </ul>
  <h2 id="signature-message">Signature Message</h2>
  <ol>
    <li>The message field in every SignatureEnvelope MUST be the hash of the canonical serialized data object.</li>
    <li>Recommended hash function: SHA-256.</li>
    <li>The hash input is strictly the canonical byte sequence of the data object (no additional metadata).</li>
    <li>Signing the message binds the signer cryptographically to the exact canonical representation of the object.</li>
  </ol>
  <h2 id="deterministic-encoding">Deterministic Encoding</h2>
  <p>There are many ways to encode raw bytes or strings, and more are being invented as we speak. It is highly
    inefficient to make these encodings contract-based. SSIMPL therefore highly recommends the use of the Multibase Data
    Format, as defined in [[Multibase]], which is deterministic.</p>
  <ul>
    <li>Multibase or Base64url encoding MUST be used consistently for any binary data (e.g., cryptographic proofs).</li>
    <li>Multibase-encoding SHOULD be used consistently for any binary data (e.g., cryptographic proofs).</li>
    <li>This ensures that all peers can reproduce the exact same byte sequence for verification.</li>
  </ul>
  <h2 id="verification-procedure">Verification Procedure</h2>
  <p>To verify a signature:</p>
  <ol>
    <li>Peer canonicalizes the data object according to the rules above.</li>
    <li>Peer hashes the canonicalized bytes to compute the message.</li>
    <li>Peer verifies that the computed message matches the message in signatureEnvelope.</li>
    <li>Peer validates the signature using the provided publicKey and algorithm.</li>
    <li>Only if all checks pass is the object considered valid.</li>
  </ol>
  <h2 id="rationale">Rationale</h2>
  <p>Canonicalization guarantees that:</p>
  <ul>
    <li>Signatures are deterministic and portable across implementations.</li>
    <li>Peers can independently verify credentials, ledger entries, and revocations.</li>
    <li>Forks, replay attacks, and accidental divergence due to encoding differences are prevented.</li>
  </ul>
  <h2 id="canonical-signature-object-pattern">Canonical Signature Object Pattern</h2>
  <p>All cryptographically signed objects in SSIMPL <strong>MUST</strong> follow a uniform, canonical structure, known
    as the <em>
    </em>SignatureEnvelope**. This ensures consistency across all signed data, including ledger entries, Verifiable
    Credential
    Roots (VCR), revocations, and delta payloads.</p>
  <h3 id="structure">Structure</h3>
  <p>Each signed object <strong>MUST</strong> include a <code>SignatureEnvelope</code> with the following structure:</p>
  <ul>
    <li><strong><code>message</code></strong> — The cryptographic hash of the canonical serialization of the
      <code>data</code> object.
    </li>
    <li><strong><code>signature</code></strong> — Object containing the signature itself:
      <ul>
        <li><code>publicKey</code> — Base64url-encoded public key corresponding to the signing private key.</li>
        <li><code>algorithm</code> — Signature algorithm used (e.g., EdDSA, ECDSA).</li>
        <li><code>value</code> — Base64url-encoded signature value.</li>
      </ul>
    </li>
    <li><strong><code>signer</code></strong> — DID of the entity producing the signature.</li>
  </ul>
  <p><strong>Example (in JSON for clarity):</strong></p>
  <pre><code class="lang-json">{
  <span class="hljs-attr">"message"</span>: <span class="hljs-string">"&lt;hash-of-canonical-data&gt;"</span>,
  <span class="hljs-attr">"signature"</span>: {
    <span class="hljs-attr">"publicKey"</span>: <span class="hljs-string">"&lt;multibase-encoded public key&gt;"</span>,
    <span class="hljs-attr">"algorithm"</span>: <span class="hljs-string">"&lt;algorithm identifier&gt;"</span>,
    <span class="hljs-attr">"value"</span>: <span class="hljs-string">"&lt;multibase-encoded signature&gt;"</span>
  },
  <span class="hljs-attr">"signer"</span>: <span class="hljs-string">"&lt;DID of signer&gt;"</span>
}
</code></pre>
  <h3 id="usage">Usage</h3>
  <ul>
    <li>Every signed object in SSIMPL, including LedgerEntry, VerifiableCredentialRoot, revocation entries, and delta
      updates,
      MUST include a signatureEnvelope.
    </li>
    <li>The message field MUST be derived from the canonical serialization of the associated data object, ensuring that
      identical logical objects produce identical hashes.
    </li>
    <li>This pattern guarantees interoperability, verifiability, and deterministic ordering for all signed objects
      across the
      network.
    </li>
  </ul>
  <h3 id="rules-and-notes">Rules and Notes</h3>
  <ul>
    <li>Optional fields in the data object MUST NOT affect the canonical hash unless explicitly defined in the
      canonicalization rules.
    </li>
    <li>Implementations MUST reject signatures if the hash does not match the canonicalized data object.</li>
    <li>Adherence to this pattern is mandatory to ensure correct ledger validation, delta verification, and revocation
      processing.
    </li>
  </ul>
  <p>This canonical signature object pattern provides a single, consistent approach for proving authorship and integrity
    across all SSIMPL objects.</p>
</section>

<hr/>

<section>
  <h1 id="ssimpl-api-specification">SSIMPL API Specification
  </h1>
  <p>This section defines the reference API for Relay Peers in the SSIMPL protocol. It provides endpoints for <strong>DID
    registration</strong>, <strong>revocation</strong>, and <strong>ledger synchronization</strong>.</p>
  <p>All requests <strong>MUST</strong> be authenticated using a <code>Bearer</code> token, containing a <strong>signed
    DID in the canonical
    SignatureEnvelope format, multibase-encoded</strong>.</p>
  <p>You can also check the open-api spec <a
      href="https://raw.githubusercontent.com/compilit/ssimpl/refs/heads/main/ssimpl-spec.json">here</a>.</p>
  <h2 id="endpoints">Endpoints</h2>

  <h3 id="register-relay-peer">Register a Relay Peer</h3>
  <p><strong>POST</strong> <code>/peer</code></p>
  <p>Purpose: Make a Relay Peer known to another Relay Peer.</p>
  <p><strong>Request payload: <a href="relaypeerannouncement">RelayPeerAnnouncement</a></strong></p>
  <p><strong>Example:</strong></p>
  <pre><code class="lang-json">{
  <span class="hljs-string">"data"</span>: {
    <span class="hljs-string">"did"</span>: "did:key:1234abc...example"
    <span class="hljs-string">"hostname"</span>: "some.hostname.org"
  },
  <span class="hljs-string">"signatureEnvelope"</span>: {
    ...
  }
}
</code></pre>
  <p><strong>Response: 201 CREATED</strong></p>
  <hr/>
  <h3 id="perform-a-handshake">Perform a handshake</h3>
  <p><strong>POST</strong> <code>/peer/identity</code></p>
  <p><strong>Purpose:</strong> Allows (Relay) Peers to check the health an initial validity of the Relay Peer</p>
  <p><strong>Request payload <a href="#signedobject-signed-t">SignedObject&lt;DID&gt;</a>:</strong></p>
  <p><strong>Example:</strong></p>
  <pre><code class="lang-json">{
  <span class="hljs-string">"data"</span>:<span class="hljs-string">"did"</span>: "did:key:1234abc...example",
  <span class="hljs-string">"signatureEnvelope"</span>: {
    ...
  }
}
</code></pre>
  <p><strong>Response: 200 OK + <a href="#signedobject-signed-t">SignedObject&lt;DID&gt;</a>:</strong></p>
  <pre><code class="lang-json">{
  <span class="hljs-string">"data"</span>:<span class="hljs-string">"did"</span>: "did:key:abc1234...example",
  <span class="hljs-string">"signatureEnvelope"</span>: {
    ...
  }
}
</code></pre>
  <hr/>
  <h3 id="request-ledger-delta">Request Ledger Delta</h3>
  <p><strong>POST</strong> <code>/ledger/delta</code></p>
  <p><strong>Purpose:</strong> Allows a Peer to request ledger entries that are newer than a given epoch, if the peer is
    out of sync.</p>
  <p><strong>Request payload <a href="#ledgerdeltarequest">LedgerDeltaRequest</a>:</strong></p>
  <p><strong>Example:</strong></p>
  <pre><code class="lang-json">{
  <span class="hljs-attr">"from"</span>: <span class="hljs-number">42</span>,
  <span class="hljs-attr">"to"</span>: <span class="hljs-number">420</span>,
  <span class="hljs-attr">"rootHash"</span>: <span class="hljs-string">"abcdef1234567890"</span>
}
</code></pre>
  <p><strong>Response: 200 OK + <a href="#ledgerdeltaresponse">LedgerDeltaResponse</a>:</strong></p>
  <p><strong>Example:</strong></p>
  <pre><code class="lang-json">{
  <span class="hljs-string">"currentEpoch"</span>: <span class="hljs-number">43</span>,
  <span class="hljs-string">"authoritativeRootHash"</span>: <span class="hljs-string">"1234abcd5678ef90"</span>,
  <span class="hljs-string">"entries"</span>: [
    {
      <span class="hljs-string">"data"</span>: {
        <span class="hljs-string">"type"</span>:<span class="hljs-string">"ENTRY"</span>,
        <span class="hljs-string">"payload"</span>: {
          <span class="hljs-string">"verifiableCredentialRoot"</span>: {
            ...
          },
          <span class="hljs-string">"proof"</span>: {
            ...
          }
        },
      },
      <span class="hljs-string">"signatureEnvelope"</span>: {
        ...
      }
    },
    <span class="hljs-string">"data"</span>: {
        <span class="hljs-string">"type"</span>:<span class="hljs-string">"REVOCATION"</span>,
        <span class="hljs-string">"payload"</span>: {
          <span class="hljs-string">"did"</span>: <span class="hljs-string">"did:key:1234abc...example"</span>,
          <span class="hljs-string">"taId"</span>: <span class="hljs-string">"ABC1234XYZ"</span>,
        },
      },
      <span class="hljs-string">"signatureEnvelope"</span>: {
        ...
      }
    }
    <span class="hljs-string">"relayPeers"</span>: [
    {
      <span class="hljs-string">"data"</span>: {
        <span class="hljs-string">"did"</span>: ...,
        <span class="hljs-string">"hostname"</span> ...,
      },
      <span class="hljs-string">"signatureEnvelope"</span>: {
        ...
      }
    }
  ]
}
</code></pre>
  <hr/>
  <h3 id="register-did">Register a DID</h3>
  <p><strong>POST</strong> <code>/ledger</code></p>
  <p>Purpose: Register a new DID on the ledger.</p>
  <p><strong>Request payload: <a href="signedobject-ledgerentry">LedgerEntry</a></strong></p>
  <p><strong>Example:</strong></p>
  <pre><code class="lang-json">{
  <span class="hljs-string">"data"</span>: {
    <span class="hljs-string">"verifiableCredentialRoot"</span>: {
      ...
    },
    <span class="hljs-string">"proof"</span>: {
      ...
    }
  },
  <span class="hljs-string">"signatureEnvelope"</span>: {
    ...
  }
}
</code></pre>
  <p><strong>Response: 201 CREATED</strong></p>
  <hr/>
  <h3 id="revoke-did">Revoke a DID</h3>
  <p><strong>PUT</strong> <code>/ledger</code></p>
  <p>Purpose: Revoke a DID by submitting a revocation payload. Providing the taId means that the related TA can NEVER be
    used again to initialize a Wallet/register a DID. The taId is mandatory for Delegated Revocation.</p>
  <p><strong>Request payload: <a href="#signedobject-ledgerentryrevocation">LedgerEntryRevocation</a></strong></p>
  <p><strong>Example:</strong></p>
  <pre><code class="lang-json">{
  <span class="hljs-string">"data"</span>: {
    <span class="hljs-string">"did"</span>: <span class="hljs-string">"did:key:z6Mkw...example"</span>,
    <span class="hljs-string">"taId"</span>: <span class="hljs-string">"(optional) ABC123XYZ"</span>
  },
  <span class="hljs-string">"signatureEnvelope"</span>: {
    ...
  }
}
</code></pre>
  <p><strong>Response: 204 NO CONTENT</strong></p>
  <hr/>
  <h2 id="shared-object-schemas">Shared Object Schemas</h2>
  <h3 id="signedobject-signed-t">SignedObject (Signed&lt;T&gt;)</h3>
  <table>
    <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>data</td>
      <td>object/string</td>
      <td>Contains the actual data this payload represents</td>
    </tr>
    <tr>
      <td>signatureEnvelope</td>
      <td>object</td>
      <td>Signature verifying the <code>data</code>. See <a href="#signatureenvelope">SignatureEnvelope</a></td>
    </tr>
    </tbody>
  </table>
  <h3 id="signedobject-ledgerentry">SignedObject: LedgerEntry</h3>
  <table>
    <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>data</td>
      <td>object</td>
      <td>Contains <code>verifiableCredentialRoot</code> and <code>proof</code></td>
    </tr>
    <tr>
      <td>signatureEnvelope</td>
      <td>object</td>
      <td>Signature verifying the integrity of <code>data</code>. See <a href="#signatureenvelope">SignatureEnvelope</a>
      </td>
    </tr>
    </tbody>
  </table>
  <h3 id="verifiablecredentialroot">VerifiableCredentialRoot</h3>
  <table>
    <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>did</td>
      <td>string</td>
      <td>The DID to be associated with the VCR - has to be the same as the one in the</td>
    </tr>
    <tr>
      <td>taId</td>
      <td>string</td>
      <td>The id related to the TA (e.g. the documentNumber). Prevents double registration and allows for deny-listing
        the TA for future registrations.
      </td>
    </tr>
    </tbody>
  </table>
  <h3 id="signedobject-ledgerentryrevocation">SignedObject: LedgerEntryRevocation</h3>
  <table>
    <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>data</td>
      <td>object</td>
      <td>Contains the DID (and optionally the taId) being revoked</td>
    </tr>
    <tr>
      <td>signatureEnvelope</td>
      <td>object</td>
      <td>Signature verifying the revocation. See <a href="#signatureenvelope">SignatureEnvelope</a></td>
    </tr>
    </tbody>
  </table>

  <h3 id="proof">Proof (Example, in case an ePassport is used as TA)</h3>
  <table>
    <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>DG15</td>
      <td>string</td>
      <td>Data group 15 proof</td>
    </tr>
    <tr>
      <td>AASignature</td>
      <td>string</td>
      <td>Active Authentication signature</td>
    </tr>
    <tr>
      <td>AAChallenge</td>
      <td>string</td>
      <td>Active Authentication challenge</td>
    </tr>
    <tr>
      <td>SOD</td>
      <td>string</td>
      <td>Security Object Document</td>
    </tr>
    </tbody>
  </table>
  <h3 id="signatureenvelope">SignatureEnvelope</h3>
  <table>
    <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>message</td>
      <td>string</td>
      <td>Canonical serialized representation of the signed data</td>
    </tr>
    <tr>
      <td>signature</td>
      <td>object</td>
      <td>Signature object containing algorithm, publicKey, and value. See <a href="#signature">Signature</a></td>
    </tr>
    <tr>
      <td>signer</td>
      <td>string</td>
      <td>DID or public key identifier of the signer</td>
    </tr>
    </tbody>
  </table>
  <h3 id="signature">Signature</h3>
  <table>
    <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>publicKey</td>
      <td>string</td>
      <td>Public key of signer</td>
    </tr>
    <tr>
      <td>algorithm</td>
      <td>string</td>
      <td>Signing algorithm</td>
    </tr>
    <tr>
      <td>value</td>
      <td>string</td>
      <td>Multibase-encoded signature value</td>
    </tr>
    </tbody>
  </table>
  <h3 id="ledgerdeltarequest">LedgerDeltaRequest</h3>
  <table>
    <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>from</td>
      <td>integer</td>
      <td>Last ledger epoch known to the peer</td>
    </tr>
    <tr>
      <td>to</td>
      <td>integer</td>
      <td>(optional) The upper boundary - In case the Peer wants 'chunked' responses</td>
    </tr>
    <tr>
      <td>rootHash</td>
      <td>string</td>
      <td>Merkle root hash of the peer's current ledger state - to verify the Relay Peers current Ledger is an
        extension of the one the Peer has
      </td>
    </tr>
    </tbody>
  </table>
  <h3 id="ledgerdeltaresponse">LedgerDeltaResponse</h3>
  <table>
    <thead>
    <th>Field</th>
    <th>Type</th>
    <th>Description</th>
    </thead>
    <tbody>
    <tr>
      <td>currentEpoch</td>
      <td>integer</td>
      <td>Current epoch of the relay peer ledger</td>
    </tr>
    <tr>
      <td>authoritativeRootHash</td>
      <td>string</td>
      <td>Merkle root hash after applying returned entries array Ordered ledger entries newer
        than lastEpoch
      </td>
    </tr>
    <tr>
      <td>entries</td>
      <td>array</td>
      <td>The entries missing from your ledger based on the provided epoch</td>
    </tr>
    </tbody>
  </table>
  <h3 id="relaypeerannouncement">RelayPeerAnnouncement</h3>
  <table>
    <thead>
    <th>Field</th>
    <th>Type</th>
    <th>Description</th>
    </thead>
    <tbody>
    <tr>
      <td>data</td>
      <td>object</td>
      <td>Containing the DID and the hostname of the Relay Peer</td>
    </tr>
    <tr>
      <td>authoritativeRootHash</td>
      <td>string</td>
      <td>Merkle root hash after applying returned entries array Ordered ledger entries newer
        than lastEpoch
      </td>
    </tr>
    <tr>
      <td>entries</td>
      <td>array</td>
      <td>The entries missing from your ledger based on the provided epoch</td>
    </tr>
    </tbody>
  </table>
</section>
<section class="appendix informative">
  <h2>Subscription-Based Credential Distribution</h2>

  <p>
    This appendix defines an optional mechanism for scoped, push-based credential
    distribution between peers. Subscriptions allow a peer to receive updates
    to specific verifiable credentials issued by another peer, without granting
    access to the full identity or affecting ledger state.
  </p>

  <p>
    Subscriptions are <strong>off-ledger</strong> and do not participate in DID
    registration, ledger consensus, Merkle state construction, or revocation
    semantics. They are purely a delivery mechanism for already valid,
    cryptographically signed credentials.
  </p>

  <h3>Subscription Model</h3>

  <p>
    A subscription represents a unidirectional relationship from a
    <em>Subject</em> to a <em>Subscriber</em>, granting the subscriber access to
    a bounded scope of credentials for a finite duration.
  </p>

  <p>
    The Subject retains full control over:
  </p>

  <ul>
    <li>Which credentials are shared</li>
    <li>The duration of the subscription</li>
    <li>The delivery mechanism</li>
    <li>Revocation of the subscription</li>
  </ul>

  <h3>Subscription Properties</h3>

  <p>
    A subscription is defined by the following conceptual properties:
  </p>

  <ul>
    <li><strong>subject_did</strong> – The DID of the credential holder</li>
    <li><strong>subscriber_did</strong> – The DID of the receiving peer</li>
    <li><strong>scope</strong> – A bounded set of credential identifiers or claim types</li>
    <li><strong>expires_at</strong> – Expiration timestamp of the subscription</li>
    <li><strong>delivery_endpoint</strong> – Endpoint or channel used for push delivery</li>
    <li><strong>signature_by_subject</strong> – Signature authorizing the subscription</li>
  </ul>

  <p>
    The exact wire format of subscription objects is implementation-defined and
    outside the scope of this specification.
  </p>
  <p>As far as authentication goes: it is recommended to use a Multibase encoded SignedObject&lt;DID&gt;.</p>

  <h3>Subscription Flow</h3>

  <ol>
    <li>The Subscriber requests access to a scoped set of credentials.</li>
    <li>The Subject evaluates the request and, if accepted, signs a subscription grant.</li>
    <li>The Subject stores the subscription locally.</li>
    <li>When a scoped credential is created, updated, or reissued, the Subject
      pushes the new signed credential to the Subscriber.
    </li>
    <li>The Subscriber verifies the credential signature and scope independently.</li>
  </ol>

  <h3>Verification</h3>

  <p>
    Subscription-delivered credentials are verified in the same way as any other
    SSIMPL verifiable credential:
  </p>

  <ul>
    <li>Signature verification using the issuer’s DID key</li>
    <li>Scope validation against the subscription grant</li>
    <li>Expiration and revocation checks as defined by the credential type</li>
  </ul>

  <p>
    No ledger interaction is required to validate a subscription or its delivered
    credentials.
  </p>

  <h3>Revocation and Expiry</h3>

  <p>
    Subscriptions are revoked by the Subject by ceasing delivery of credentials
    and optionally notifying the Subscriber. Expired subscriptions MUST NOT be
    used to deliver new credentials.
  </p>

  <p>
    Subscription revocation does not affect the validity of previously issued
    credentials, which remain verifiable according to their own signatures and
    expiry rules.
  </p>

  <h3>Security Considerations</h3>

  <ul>
    <li>Subscriptions MUST be explicitly authorized by the Subject via signature.</li>
    <li>Subscribers MUST verify credential signatures independently.</li>
    <li>Relay Peers MUST NOT interpret or enforce subscription semantics.</li>
    <li>Subscriptions MUST NOT be used to infer global identity state.</li>
  </ul>

  <p>
    Implementations SHOULD take care to minimize metadata leakage through
    delivery endpoints and timing correlations.
  </p>

</section>
</body>
</html>