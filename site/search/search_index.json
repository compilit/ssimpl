{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"1. SSIMPL - Specification The SSIMPL protocol described in the following specification addresses a few problems that have existed since the early days of the internet \u2014 certainly since Web 2.0: How do you keep the owner of the online identity in control of their identity data? There have been several iterations of OAuth in the past, one of which (Open ID Connect), was meant to add an identification layer to a protocol that's otherwise solely used for delegated authorization. This identity layer, however, has never been implemented in a way that anyone can truly rely on. It requires a certain amount of trust, which is provided in the form of billion-dollar companies saying \"this data belongs to the person who just logged in\". But it adds no guarantees about the validity of those claims. In order to minimize the amount of trust necessary for identification, it is essential that individuals are capable of managing their digital identity themselves, this is known as SSI - Self-Sovereign-Identity . But SSI is still worth as much as an identity provided by a multinational if it is not verified. How do you verify someone\u2019s digital identity? Online, everyone can claim to anyone. For some systems - like social media - that could be fine. But for professional services, it is of the utmost importance that all parties of a transaction are actually who they say they are. This issue has become even more critical with the rise of AI and bots capable of impersonating individuals with minimal effort. SSIMPL stands for Self-Sovereign Identity & Mondial Pseudonymous Ledger. Which tells us already quite a bit about its components. SSIMPL tries to find a balance between centralised and decentralised systems. It creates a bridge between the physical and digital worlds through authority-backed cryptographic proof. Therefor, implementing SSIMPL requires a trusted central authority (such as a government) that supports some form of cryptography-based identification for individuals. Read more about centralised authorities in a decentralised system . 1.1 The wallet The wallet must be a decentralised BIP32-compliant implementation backed-up up with a BIP39-compliant mnemonic phrase (stored offline). This wallet contains both a root keypair that can be used to sign and verify data and to authorize the bearer online, and all claims of the owner. It also supports creating child keypairs for pseudonymous authentication. The root public key is used to generate a DID (decentralised Identifier), which is then signed by the neutral third party. Furthermore, all encoded data, like the cryptographic keys, must be encoded using Multibase-encoding to ensure all peers of all possible future implementations always know which encoding is used. At this point, in the spirit of Open ID Connect, the user has all the components needed to authenticate themselves online at multiple levels: Level 0: The DID belongs to a human being. Level 1: Level 0 + unverified claims attached to the DID (requested via scope). Level 2: Level 1 + verified claims attached to the DID (requested via scope). Level 0 is sufficient to prove the user is not an AI or bot. Level 1 may be used when specific, unverified attributes are needed, like an address or a phone number. Level 2 provides verified claims. The requestor of these claims merely needs to request a certain scope of claims. You, as the owner then needs to approve this request and send them the requested claims, while signing them with your wallet. At the same time, the user will have the ability to cryptographically sign anything they would want to be associated with. In other words: if they would like to be able to proof they were the original creator of some digital content, all they would need to do is sign it. Other people could sign it as well, of course, but signature cannot be created using a past date. So the first one to sign something, always can proof they were the original creator. 1.2 Authentication All users of the SSIMPL protocol must possess a modern Standardised e-passport . These contain cryptographic material used to verify the legitimacy of the passport, thereby delegating the authority of the identity represented to the bearer\u2014assuming basic checks are met (e.g., does the bearer match the photo?). This bearer token-like construct can only be trusted if people take good care of their passports and also follow basic protocols in case of a lost or stolen passport. By reading the NFC chip, one will get access to so-called 'data groups'. Each group represents some other part of the identity or the passport. While reading the NFC chip, an implementation of SSIMPL is required to perform an Active-Authentication challenge, which makes the passport sign a randomly generated challenge with its embedded private key, which can then be verified by the key found in DG15. This challenge is there to proof that the passport was not in fact cloned or otherwise tempered with. The result of the challenge will be stored in the id wallet. DG11 contains the personal details of the owner which can be the first basic, verified claims, stored in the id wallet. 1.2 WebRTC In order to be able to establish direct communication between peers through WebRTC, a Signal-, STUN- and TURN-server are required. These are used for peers to locate each other, after which, further communication is truly p2p. 1.3 IPFS Some details need to be stored in a way that anyone can access them, preferably without a centralised server. The IPFS is a good candidate for this. The IPFS needs to host a file that contains all registered, invalidated/expired DIDs (the ledger). Every time another version of this file is uploaded, a pointer-file also needs to be updated. This pointer-file is a file containing static data whose metadata is updated to point to the new version of the ledger. To register, one needs to submit a \"root claim\", which ties the identity's DID to the document they used to authenticate themselves. Similarly, this same ledger-entry needs to be updated for invalidations. Each instance integrating with the IPFS needs to implement these business rules: A user can only append entries if the entry doesn't exist yet, (composite key of DID + identityDocumentHash). A user can only invalidate their own root claim if it exists. An invalidated root claim cannot be altered again. These rules must be implemented by checking the signature for each entry against the provided DID. rootClaim: { \"data\": { \"did\": \"\", \"identityDocumentHash\": \"\", \"createdAt\": \"2025-04-09T10:15:30+07:00.\", \"invalidatedAt\": null }, \"signature\": { \"publicKey\": \"string\", \"algorithm\": \"string\", \"value\": \"string\" }, \"signer\": \"string\" } identityDocumentHash: const identityDocumentHash = sha256( JSON.stringify( { \"nationality\": \"DUTCH\", \"dateOfBirth\": \"30051988\", \"firstNames\": \"JOHN HARVEY\", \"lastName\": \"DOE\", \"documentNumber\": \"ABC12345XYZ\", \"documentType\": \"P\", \"documentSubType\": \"P\", \"documentExpiryDate\": \"01012050\" } ) ) 2. DoaToa - a SSIMPL implementation DoaToa (Decentralised Open Auth & Trusted Open Auth) is the first SSIMPL implementation created. It consists of a client-side app (the id-wallet) and a few stateless microservices necessary to help set up decentralised communication and sharing of data. These microservices, while being centralised components, are meant to be 'the first of many' open-source interchangeable implementations. The same goes for the id-wallet. As long as the specification is followed, multiple implementations of both the centralised components and the wallet, should be able to co-exist. 2.1 Decentralisation In order to fully implement SSI, a user needs to have full control over their own data. There are several ways to accomplish this (using a hardware wallet for example), but DoaToa relies on a somewhat controversial take: most people have a smartphone and treat it with more respect than their passport. Smartphones these days lack true HSMs (Hardware Security Modules), which would be the best place for cryptographic material to exist. Due to this (hopefully temporary) imperfection in smartphones, DoaToa uses the keystores that exist on devices: Keychain on iOS and the KeyStore on Android. This introduces a few risks that need to be mitigated: If the device is lost/stolen, the related wallet needs to be invalidated. - This is achieved by registering the DID on a decentralised ledger, stored on the IPFS. DoaToa provides this functionality. It would require you use the mnemonic phrase on a new device to re-create your wallet, then invalidate it. The user can then create a new wallet again. If a user switches devices, the wallet needs to be re-created. - The mnemonic phrase can be used to re-create the old wallet. Always do take care to either delete the wallet from the device, or to factory-reset the device. If the mnemonic phrase is lost/stolen. - The user will need to invalidate their current DID and create a new wallet (which will also mean the user gets a new mnemonic phrase) A user loses both their mnemonic phrase and their phone. - This scenario should be prevented at all costs , since everything relies on that mnemonic phrase. It is advised to use a (maybe even redundant) cold storage to keep the mnemonic phrase safe. 2.2 Use-cases Each wallet has the capability to share data to another wallet in the form of a data sharing event, or a subscription. Ad-hoc data sharing event: the receiver sends a request containing the scope of the requested data, and their DID. This request is used to establish a WebRTC connection between the two peers, which is then used to share the data. This scenario is also quite similar to how an authentication request could be fulfilled. Although the use of WebRTC for that is optional when backed by a backend server. See UCAN . Subscriptions: the receiver sends a request containing the scope of the requested data, a public key (used for sharing a secret. E.g. Hybrid-Encryption or DHKE), the DID of the requestor and some optional metadata concerning the duration of the subscription.This request is used to establish a WebRTC. A symmetric key for encryption is either generated or resolved based on the provided public key. The data is gathered and encrypted with this symmetric key. In case of Hybrid-Encryption, the symmetric key is then encrypted using the public key. The encrypted data (and optionally the encrypted key) are then publicly stored on the IPFS. Finally, the location to this subscription is shared. While the IPFS does not support updating files, as it would require to change the CID used to retrieve the data, DoaToa stores a pointer to the file in question. The file itself never changes, but its metadata is updated to point to the latest version of the file thus allowing the file to be updated. The only implication is that the latest version of the file needs to be requested through the central DoaToa server. A direct WebRTC connection could also be used to update a subscription. However, a WebRTC connection requires both sides to actively set it up, which means that syncing between peers becomes occasionally at best when both peers happen to be online at the same time. There are several options for sending the request to the client app. One is through a simple qr-code which is either used to set up a WebRTC connection. Another could be by providing your e-mail address which you open on your mobile device containing the wallet, which in term opens a deep link in the app to authentication yourself. 2.3 Centralised component In order to establish WebRTC connections, some centralised components are required for peers to find each other. As soon as the connection is created, all data will be moved directly from peer to peer. So there is no need to trust the central server. In order to store data on the IPFS while leveraging metadata to 'update' files, a central server is also required. Finally, in order to ensure every SSIMPLE DID out there is actually from the ones they claim to be, DoaToa can be presented with the cryptographic material coming from your passport along with the DID. If DoaToa can verify this material, the DID will be signed by DoaToa. Verification of this material goes as follows: The passport contains all the means for an Active Authentication challenge, which needs to be passed. This challenge makes sure the cryptographic material actually comes from the passport in the hands of the owner. The passport contains a hash list of all the data on it. This hash list is signed by an authorised party and the related public key can be found in the public ICAO master list. DoaToa checks if this is the case and verifies the signature. This limited set of features is provided by DoaToa, but could relatively easily be implemented by other enthusiasts. The only requirements are that they are open-sourced. Each provider of these features will require a DID as well. You can request DoaToa to register your DID as a provider.","title":"Home"},{"location":"#1-ssimpl-specification","text":"The SSIMPL protocol described in the following specification addresses a few problems that have existed since the early days of the internet \u2014 certainly since Web 2.0: How do you keep the owner of the online identity in control of their identity data? There have been several iterations of OAuth in the past, one of which (Open ID Connect), was meant to add an identification layer to a protocol that's otherwise solely used for delegated authorization. This identity layer, however, has never been implemented in a way that anyone can truly rely on. It requires a certain amount of trust, which is provided in the form of billion-dollar companies saying \"this data belongs to the person who just logged in\". But it adds no guarantees about the validity of those claims. In order to minimize the amount of trust necessary for identification, it is essential that individuals are capable of managing their digital identity themselves, this is known as SSI - Self-Sovereign-Identity . But SSI is still worth as much as an identity provided by a multinational if it is not verified. How do you verify someone\u2019s digital identity? Online, everyone can claim to anyone. For some systems - like social media - that could be fine. But for professional services, it is of the utmost importance that all parties of a transaction are actually who they say they are. This issue has become even more critical with the rise of AI and bots capable of impersonating individuals with minimal effort. SSIMPL stands for Self-Sovereign Identity & Mondial Pseudonymous Ledger. Which tells us already quite a bit about its components. SSIMPL tries to find a balance between centralised and decentralised systems. It creates a bridge between the physical and digital worlds through authority-backed cryptographic proof. Therefor, implementing SSIMPL requires a trusted central authority (such as a government) that supports some form of cryptography-based identification for individuals. Read more about centralised authorities in a decentralised system .","title":"1. SSIMPL - Specification"},{"location":"#11-the-wallet","text":"The wallet must be a decentralised BIP32-compliant implementation backed-up up with a BIP39-compliant mnemonic phrase (stored offline). This wallet contains both a root keypair that can be used to sign and verify data and to authorize the bearer online, and all claims of the owner. It also supports creating child keypairs for pseudonymous authentication. The root public key is used to generate a DID (decentralised Identifier), which is then signed by the neutral third party. Furthermore, all encoded data, like the cryptographic keys, must be encoded using Multibase-encoding to ensure all peers of all possible future implementations always know which encoding is used. At this point, in the spirit of Open ID Connect, the user has all the components needed to authenticate themselves online at multiple levels: Level 0: The DID belongs to a human being. Level 1: Level 0 + unverified claims attached to the DID (requested via scope). Level 2: Level 1 + verified claims attached to the DID (requested via scope). Level 0 is sufficient to prove the user is not an AI or bot. Level 1 may be used when specific, unverified attributes are needed, like an address or a phone number. Level 2 provides verified claims. The requestor of these claims merely needs to request a certain scope of claims. You, as the owner then needs to approve this request and send them the requested claims, while signing them with your wallet. At the same time, the user will have the ability to cryptographically sign anything they would want to be associated with. In other words: if they would like to be able to proof they were the original creator of some digital content, all they would need to do is sign it. Other people could sign it as well, of course, but signature cannot be created using a past date. So the first one to sign something, always can proof they were the original creator.","title":"1.1 The wallet"},{"location":"#12-authentication","text":"All users of the SSIMPL protocol must possess a modern Standardised e-passport . These contain cryptographic material used to verify the legitimacy of the passport, thereby delegating the authority of the identity represented to the bearer\u2014assuming basic checks are met (e.g., does the bearer match the photo?). This bearer token-like construct can only be trusted if people take good care of their passports and also follow basic protocols in case of a lost or stolen passport. By reading the NFC chip, one will get access to so-called 'data groups'. Each group represents some other part of the identity or the passport. While reading the NFC chip, an implementation of SSIMPL is required to perform an Active-Authentication challenge, which makes the passport sign a randomly generated challenge with its embedded private key, which can then be verified by the key found in DG15. This challenge is there to proof that the passport was not in fact cloned or otherwise tempered with. The result of the challenge will be stored in the id wallet. DG11 contains the personal details of the owner which can be the first basic, verified claims, stored in the id wallet.","title":"1.2 Authentication"},{"location":"#12-webrtc","text":"In order to be able to establish direct communication between peers through WebRTC, a Signal-, STUN- and TURN-server are required. These are used for peers to locate each other, after which, further communication is truly p2p.","title":"1.2 WebRTC"},{"location":"#13-ipfs","text":"Some details need to be stored in a way that anyone can access them, preferably without a centralised server. The IPFS is a good candidate for this. The IPFS needs to host a file that contains all registered, invalidated/expired DIDs (the ledger). Every time another version of this file is uploaded, a pointer-file also needs to be updated. This pointer-file is a file containing static data whose metadata is updated to point to the new version of the ledger. To register, one needs to submit a \"root claim\", which ties the identity's DID to the document they used to authenticate themselves. Similarly, this same ledger-entry needs to be updated for invalidations. Each instance integrating with the IPFS needs to implement these business rules: A user can only append entries if the entry doesn't exist yet, (composite key of DID + identityDocumentHash). A user can only invalidate their own root claim if it exists. An invalidated root claim cannot be altered again. These rules must be implemented by checking the signature for each entry against the provided DID.","title":"1.3 IPFS"},{"location":"#rootclaim","text":"{ \"data\": { \"did\": \"\", \"identityDocumentHash\": \"\", \"createdAt\": \"2025-04-09T10:15:30+07:00.\", \"invalidatedAt\": null }, \"signature\": { \"publicKey\": \"string\", \"algorithm\": \"string\", \"value\": \"string\" }, \"signer\": \"string\" }","title":"rootClaim:"},{"location":"#identitydocumenthash","text":"const identityDocumentHash = sha256( JSON.stringify( { \"nationality\": \"DUTCH\", \"dateOfBirth\": \"30051988\", \"firstNames\": \"JOHN HARVEY\", \"lastName\": \"DOE\", \"documentNumber\": \"ABC12345XYZ\", \"documentType\": \"P\", \"documentSubType\": \"P\", \"documentExpiryDate\": \"01012050\" } ) )","title":"identityDocumentHash:"},{"location":"#2-doatoa-a-ssimpl-implementation","text":"DoaToa (Decentralised Open Auth & Trusted Open Auth) is the first SSIMPL implementation created. It consists of a client-side app (the id-wallet) and a few stateless microservices necessary to help set up decentralised communication and sharing of data. These microservices, while being centralised components, are meant to be 'the first of many' open-source interchangeable implementations. The same goes for the id-wallet. As long as the specification is followed, multiple implementations of both the centralised components and the wallet, should be able to co-exist.","title":"2. DoaToa - a SSIMPL implementation"},{"location":"#21-decentralisation","text":"In order to fully implement SSI, a user needs to have full control over their own data. There are several ways to accomplish this (using a hardware wallet for example), but DoaToa relies on a somewhat controversial take: most people have a smartphone and treat it with more respect than their passport. Smartphones these days lack true HSMs (Hardware Security Modules), which would be the best place for cryptographic material to exist. Due to this (hopefully temporary) imperfection in smartphones, DoaToa uses the keystores that exist on devices: Keychain on iOS and the KeyStore on Android. This introduces a few risks that need to be mitigated: If the device is lost/stolen, the related wallet needs to be invalidated. - This is achieved by registering the DID on a decentralised ledger, stored on the IPFS. DoaToa provides this functionality. It would require you use the mnemonic phrase on a new device to re-create your wallet, then invalidate it. The user can then create a new wallet again. If a user switches devices, the wallet needs to be re-created. - The mnemonic phrase can be used to re-create the old wallet. Always do take care to either delete the wallet from the device, or to factory-reset the device. If the mnemonic phrase is lost/stolen. - The user will need to invalidate their current DID and create a new wallet (which will also mean the user gets a new mnemonic phrase) A user loses both their mnemonic phrase and their phone. - This scenario should be prevented at all costs , since everything relies on that mnemonic phrase. It is advised to use a (maybe even redundant) cold storage to keep the mnemonic phrase safe.","title":"2.1 Decentralisation"},{"location":"#22-use-cases","text":"Each wallet has the capability to share data to another wallet in the form of a data sharing event, or a subscription. Ad-hoc data sharing event: the receiver sends a request containing the scope of the requested data, and their DID. This request is used to establish a WebRTC connection between the two peers, which is then used to share the data. This scenario is also quite similar to how an authentication request could be fulfilled. Although the use of WebRTC for that is optional when backed by a backend server. See UCAN . Subscriptions: the receiver sends a request containing the scope of the requested data, a public key (used for sharing a secret. E.g. Hybrid-Encryption or DHKE), the DID of the requestor and some optional metadata concerning the duration of the subscription.This request is used to establish a WebRTC. A symmetric key for encryption is either generated or resolved based on the provided public key. The data is gathered and encrypted with this symmetric key. In case of Hybrid-Encryption, the symmetric key is then encrypted using the public key. The encrypted data (and optionally the encrypted key) are then publicly stored on the IPFS. Finally, the location to this subscription is shared. While the IPFS does not support updating files, as it would require to change the CID used to retrieve the data, DoaToa stores a pointer to the file in question. The file itself never changes, but its metadata is updated to point to the latest version of the file thus allowing the file to be updated. The only implication is that the latest version of the file needs to be requested through the central DoaToa server. A direct WebRTC connection could also be used to update a subscription. However, a WebRTC connection requires both sides to actively set it up, which means that syncing between peers becomes occasionally at best when both peers happen to be online at the same time. There are several options for sending the request to the client app. One is through a simple qr-code which is either used to set up a WebRTC connection. Another could be by providing your e-mail address which you open on your mobile device containing the wallet, which in term opens a deep link in the app to authentication yourself.","title":"2.2 Use-cases"},{"location":"#23-centralised-component","text":"In order to establish WebRTC connections, some centralised components are required for peers to find each other. As soon as the connection is created, all data will be moved directly from peer to peer. So there is no need to trust the central server. In order to store data on the IPFS while leveraging metadata to 'update' files, a central server is also required. Finally, in order to ensure every SSIMPLE DID out there is actually from the ones they claim to be, DoaToa can be presented with the cryptographic material coming from your passport along with the DID. If DoaToa can verify this material, the DID will be signed by DoaToa. Verification of this material goes as follows: The passport contains all the means for an Active Authentication challenge, which needs to be passed. This challenge makes sure the cryptographic material actually comes from the passport in the hands of the owner. The passport contains a hash list of all the data on it. This hash list is signed by an authorised party and the related public key can be found in the public ICAO master list. DoaToa checks if this is the case and verifies the signature. This limited set of features is provided by DoaToa, but could relatively easily be implemented by other enthusiasts. The only requirements are that they are open-sourced. Each provider of these features will require a DID as well. You can request DoaToa to register your DID as a provider.","title":"2.3 Centralised component"},{"location":"concepts/","text":"Concepts 1. BIP BIP stands for Bitcoin Improvement Proposal \u2014 it\u2019s a formal design document used to propose changes or additions to Bitcoin\u2019s protocol, processes, or tools. It\u2019s essentially the \u201cRFC\u201d (Request for Comments) system for Bitcoin. Each BIP has: \u2022 A number (e.g., BIP-39) \u2022 A type (Standards Track, Informational, or Process) \u2022 A status (Draft, Proposed, Final, etc.) \u2022 A detailed specification of the proposed change. For example: \u2022 BIP-32 defines hierarchical deterministic (HD) wallets. \u2022 BIP-39 defines mnemonic phrases (seed words). \u2022 BIP-44 defines a multi-account wallet structure. While SSIMPL has nothing to do with Bitcoin, or even blockchains, it does rely some of the same concepts. 1.1 BIP32 BIP32 (Bitcoin Improvement Proposal 32) defines Hierarchical Deterministic (HD) wallets, which allow you to derive a tree of keypairs from a single root seed. How it works: \u2022 Starts with a single seed (often from a BIP39 mnemonic). \u2022 From that seed, it deterministically derives a master keypair (private + public key). \u2022 You can derive child keypairs from the master, and children of those, forming a tree structure. Key features: \u2022 One backup = all keys: Backing up the seed gives access to all derived keys. \u2022 Key separation: You can derive independent identities (child keys) without compromising the master. \u2022 Public derivation: Given a parent public key, you can derive child public keys (but not private keys). \u2022 Hardened derivation: A safer variant where child keys can\u2019t be derived from public keys, but requires the parent private key. 1.2 BIP39 BIP39 (Bitcoin Improvement Proposal 39) defines a way to represent a deterministic wallet\u2019s private key using a human-readable set of words, called a mnemonic phrase. How it works: \u2022 A cryptographically strong random number (entropy) is generated. \u2022 That number is converted into a sequence of 12\u201324 words chosen from a predefined list of 2048 words. \u2022 This phrase can be used to derive a seed, which in turn can generate a hierarchy of keys (e.g., via BIP32). Key properties: \u2022 Mnemonic = backup: If you lose your device, you can recover your entire wallet using the phrase. \u2022 Language-agnostic: Wordlists exist for multiple languages. \u2022 Deterministic: The same phrase will always regenerate the same wallet. 2. Self-Sovereign-Identity Self-Sovereign Identity (SSI) is a Decentralised identity model where individuals control their own digital identities without relying on central authorities. The main issue which the concept SSI usually tends to ignore is 'truth'. As long an individual is in complete control of their own digital identity, who is to say this individual is not impersonating some other individual, or worse, conjuring up a completely new non-existing one. Cryptography can verify who issued a claim and whether it was tampered with, but it cannot verify the truthfulness of the claim itself. The validity of claims like a name, nationality, or birthdate ultimately depends on who the issuer is and whether they are trusted. However, since this requires authorities to be fully aligned with Web3 standards, we hit a dead end. Currently, most (if not all) authorities don't have any way to issue DIDs. So what DoaToa does, is reversing the flow yet again: an individual can create their own DID along with the related cryptographic keys. Which is actually in line with the entire idea of decentralisation. But 'claims' an individual makes are divided into 2 categories: formal and informal. 2.1 DID Decentralised IDentifier. A DID is a globally unique identifier that is not controlled by a central authority. Unlike traditional identifiers (usernames, emails, etc.), a DID is linked to a cryptographic keypair, allowing users to prove ownership without relying on a centralised system. A DID follows this format: did:<method>:<identifier> In DoaToa, primarily the 'key' method is used. This means that each 'identifier' part is actually the public part of a specific cryptographic public/private keypair. Each user is responsible for their own private key, which is used to sign data. The public key can always be used to verify the signature. The 'key' method also means there is no real need for a DID document, which is part of the DID spec. 2.2 Informal Claims Informal claims can be made within certain scopes, where the user provides their own data along with their signature. By nature, these claims cannot be verified by an authority. However, other identities can attest to a claim by signing it, effectively endorsing its validity. This attestation carries moral responsibility, as the signer\u2019s DID and signature become publicly associated with the claim. 2.3 Formal Claims Formal claims cannot be self-issued; they must come from a recognized authority. At this point in time, the only formal claims available to a DoaToa user, are the ones coming from their passport. These can be used to chain other claims of course: by taking your full name and birthdate, you can match then with the names and birthdate written on an official diploma. This functionality is out of scope for now. 3. European e-Passports A European e-passport relies on a set of international standards to prove its authenticity and integrity using cryptographic techniques. These standards work together to ensure the data on the passport is both verifiable and resistant to tampering or cloning. 3.1 ICAO Doc 9303 The foundational specification for Machine Readable Travel Documents (MRTDs). It defines: The structure and contents of the e-passport chip. Cryptographic protocols such as: Passive Authentication (PA): Verifies the integrity and authenticity of the stored data using digital signatures from the issuing authority. Active Authentication (AA): Ensures the chip hasn\u2019t been cloned by using a private key challenge/response protocol. 3.2 ISO/IEC 7816 (Parts 4, 8, 9) Standards for electronic identification cards with contacts, adapted for contactless chips in e-passports: Part 4: File system structure and command set (APDUs). Part 8: Security-related functions including authentication. Part 9: Access control and secure messaging. These standards allow secure and standardized access to the data groups (DG1\u2013DG15) on the chip. 3.3 ISO/IEC 14443 (Parts 1\u20134) Defines the physical and communication characteristics for contactless smartcards: Enables NFC communication between passport chips and readers. Standard across all ICAO-compliant e-passports. 3.4 ISO/IEC 7501-1 Specifies the physical format and layout of machine-readable passports, including: Dimensions Data placement The Machine Readable Zone (MRZ), which is used to derive keys for secure access (e.g., Basic Access Control). 3.5 CSCA and DSC Certificates Each country operates a Country Signing Certificate Authority (CSCA) and issues Document Signer Certificates ( DSCs) : The CSCA\u2019s public key is distributed globally. The DSC signs the data on each passport. Verifiers use the CSCA chain to validate the DSC signature and ensure the data\u2019s authenticity. Together, these standards form the cryptographic backbone that allows e-passports to be trusted across borders. 4. WebRTC WebRTC (Web Real-Time Communication) is an open-source project and API standard that enables peer-to-peer communication directly between browsers or mobile apps, without requiring intermediate servers for media routing. 4.1 Key Features Real-time audio and video streaming. Data channels for arbitrary peer-to-peer data transfer. Low latency , ideal for voice/video calls, gaming, and file sharing. 4.2 How It Works Signaling (out of scope for the WebRTC-spec): Exchanging connection info (e.g., IPs, codecs) between peers using a separate method (like WebSocket). ICE (Interactive Connectivity Establishment): Finds the best path through NATs/firewalls. DTLS/SRTP: Ensures encryption and secure transport . STUN/TURN servers: Help peers connect when direct connections are blocked. WebRTC is supported by all major browsers and is a core building block for modern real-time web applications. 5. UCAN - User Controlled Authorization Networks To align with Web3 standards, DoaToa has adopted UCAN. UCAN challenges the traditional client-server model, shifting control to the client. Clients generate their own JWTs, specifying the request and resource they intend to access. Each JWT is signed with the user\u2019s private key, allowing the server to verify the signature and determine whether access should be granted. This essentially reverses the OAuth 2.0 flow, where clients request a server-issued JWT with specific scopes. It should be noted that UCAN was originally designed for \"delegated authorization\". Meaning, an issuer creates a token that allows the bearer of the token to perform certain actions on certain resources. For authentication, an addition is required. 5.1 'UCAN Connect' Like Open ID Connect adds an identification layer to OAuth2, UCAN Connect also adds an identification layer to UCAN. By embedding (verified) claims within UCAN JWTs, authentication systems eliminate the need to store user data, further decentralizing trust. The receiver of the token notifies the issuer of the token which scope(s) they would like to receive, and the issuer adds the related claims to the token. The receiver also should specify where the JWT should be sent. 5.2 Implementation of the UCAN Connect flow So how would all of this work in a real-world example? Let's set up a scenario. We start with three parties: Party A. The owner of the identity, aka the issuer of the UCAN token. Party B. The id-wallet of the owner (like DoaToa). Party C. A website, let's say a webshop called \"foo-bar.baz\". Party D. The server of \"foo-bar.baz\". Pre-requisite: both Party A/B, and Party C/D have a DID, signed by DoaToa. For a non-natural person, this means a DID from someone inside the legal entity, willing to represent the legal entity. Typically, A will visit C, which at some point requires A to identify themselves (to complete an order, for example). Party C has to create a scannable image (like a QR-code), which provides Party B all necessary information to authenticate Party A: The DID of Party C. The scopes of Party A that Party C requires. A connection proposal. Containing either a channel id - used to set up a WebRTC channel, or an authentication endpoint (Party D) - to which the token should be sent. This payload MUST be a multibase-encoded JSON message: { \"requestor\": \"did:key:a1b2c3d4e5f6g7h8ij9k0\", \"scopes\": [ \"did\", \"private-address\" ], \"destination\": { \"channelId\": \"someId\", \"authenticationEndpoint\": \"someEndpoint\" } } 6. Authentication through WebRTC Party D SHOULD initiate the WebRTC connection using the specified channel id. Party C is also allowed to do so, but that would expose the UCAN token to Party C, which is less secure. Party B will do so some seconds after scanning the payload. After the connection is set up, Party B will send the UCAN Connect token. Afterward, the connection is closed. 6.1 Authentication through an endpoint The Party D connection endpoint MUST have the same domain as that of Party C. A subdomain is allowed. The connection endpoint MUST be as follows: ```http request POST /ucan-connect/auth HTTP/2 Authorization: \"Bearer ${theUCANConnectToken}\" (no body should be provided) ``` This endpoint MUST respond with either a 200 OK or a 401 UNAUTHENTICATED 200 OK: the tokens' signature matches the provided DID 401 UNAUTHENTICATED: the tokens' signature does not match the provided DID. The DID will be in the 'claims' array of the UCAN token. Or the DID does not match the specified public key. Then Party D SHOULD provide Party C with another token, specific for the current context, so Party C doesn't need to know anything about Party A. 6.2 Delegated signing using UCAN By creating a dedicated, short-lived and identity-bound token (by setting receivers' DID as the audience of the token), a user can delegate signing authority towards another entity, like the website they are currently on. The UCAN token is then embedded in the signature JWT in the prf-array. This is relevant if the user is adding content to the website and the website wants to have this content bound to a DID. The implications are that all content on the internet HAS to be tied to an author, producer, etc. Which means that fraudulent content, like non-consensual, AI-generated media, will have to signed as well. 7. Cryptography Achieving true decentralization requires users to handle complex cryptographic operations. To make this accessible, all cryptographic functionality should be encapsulated within a user-friendly interface \u2014 a \u2018wallet\u2019. This wallet contains at least one cryptographic keypair: A root AES key for encrypting and decrypting the user\u2019s data. An EC-based public/private key pair for signing and verifying data. These algorithms are widely recognized standards, so I won\u2019t delve into their inner workings\u2014Wikipedia is your friend for that. With these keys, users can encrypt, decrypt, sign, and verify data entirely on the client side, ensuring full control over their information. In the subscription system, an additional key pair is introduced. This keypair facilitates sharing a derived AES key\u2014not the root AES key, but a deterministically generated AES key unique to each subscription. 7.1 Post-Quantum disclaimer With the inevitable advent of quantum computing, these algorithms will change eventually. Currently, there are several candidates which could potentially take over the aforementioned algorithms. DoaToa will adapt accordingly. The biggest concern lies in asymmetric encryption, which is used for signing and sharing of secrets. Through Shor's algorithm, the asymmetric encryption algorithms we currently rely on will be cracked, meaning that private keys can be derived based on public keys. This is why everything related to asymmetric encryption should have an expiration time. And this is also part of the design of DoaToa: most data stays client-side. 8. IPFS IPFS (InterPlanetary File System) is a peer-to-peer distributed file system that aims to make the web more * Decentralised , resilient , and permanent *. Traditionally, large tech companies have been responsible for storing data. This centralised model comes with several drawbacks, including single points of failure, high costs, and control over access to information. Decentralised storage offers an alternative by distributing data across multiple nodes instead of relying on a central server. This approach provides several advantages: Eliminates Single Points of Failure \u2013 No central server means no single point of failure, reducing the risk of data loss or downtime. Censorship Resistance \u2013 Data isn\u2019t controlled by a single entity, making it harder for governments or organizations to censor or remove information. Improved Availability \u2013 Multiple copies of data are stored across a network, ensuring accessibility even if some nodes go offline. Lower Costs \u2013 Users can share and utilize spare storage from others, reducing infrastructure costs compared to traditional cloud providers. Tamper Resistance \u2013 Cryptographic hashing and content addressing ensure data integrity and prevent unauthorized modifications. Trustless Environment \u2013 No need to rely on a central authority; cryptographic verification ensures data is stored and retrieved correctly. For DoaToa, a peer-to-peer approach aligns best with its principles. The InterPlanetary File System (IPFS) is a Decentralised, peer-to-peer protocol for storing and sharing data. Unlike traditional location-based addressing (where URLs point to specific servers), IPFS uses content addressing, identifying files by their cryptographic hash (CID). 8.1 Key Features of IPFS: Content Addressing \u2013 Files are identified by unique hashes, ensuring integrity and deduplication. Peer-to-Peer Distribution \u2013 Files are retrieved from multiple nodes rather than a central server. Versioning \u2013 IPFS can track changes, similar to Git. Caching \u2013 Popular content is cached across the network for faster access. Interoperability \u2013 Works well with blockchain and Decentralised applications (dApps). 8.2 Problems IPFS Solves: Redundancy & Availability \u2013 Data remains accessible without reliance on a single server. Censorship Resistance \u2013 Information remains online as long as at least one node hosts it. Efficient Content Delivery \u2013 Data is retrieved from the nearest available node, reducing latency. However, IPFS alone does not guarantee permanent storage\u2014data can disappear if no node continues to host it. To ensure persistence, data must be pinned. This can be done either manually (free) or through a pinning service. Currently, DoaToa uses a pinning service, but in the future, your wallet will evolve to support self-hosting and pinning, ensuring full control over data storage 9. Multibase Encoding On the internet, a lot of raw data (bytes) is transported using something called base encoding. These encodings essentially turn the raw bytes into a piece of transportable and near-readable text. But when you wish to access the raw bytes again on the receiving side, you need to know which encoding was used in order to decode it. But there are a lot of different encodings to choose from. This means that encoding and decoding must be well-documented. With Multibase encoding, a special reserved character for each specific encoding is appended to the encoded value which indicates which encoding was used. This means that anyone receiving the encoded bytes can always decode it. More can be read here .","title":"Concepts"},{"location":"concepts/#concepts","text":"","title":"Concepts"},{"location":"concepts/#1-bip","text":"BIP stands for Bitcoin Improvement Proposal \u2014 it\u2019s a formal design document used to propose changes or additions to Bitcoin\u2019s protocol, processes, or tools. It\u2019s essentially the \u201cRFC\u201d (Request for Comments) system for Bitcoin. Each BIP has: \u2022 A number (e.g., BIP-39) \u2022 A type (Standards Track, Informational, or Process) \u2022 A status (Draft, Proposed, Final, etc.) \u2022 A detailed specification of the proposed change. For example: \u2022 BIP-32 defines hierarchical deterministic (HD) wallets. \u2022 BIP-39 defines mnemonic phrases (seed words). \u2022 BIP-44 defines a multi-account wallet structure. While SSIMPL has nothing to do with Bitcoin, or even blockchains, it does rely some of the same concepts.","title":"1. BIP"},{"location":"concepts/#11-bip32","text":"BIP32 (Bitcoin Improvement Proposal 32) defines Hierarchical Deterministic (HD) wallets, which allow you to derive a tree of keypairs from a single root seed. How it works: \u2022 Starts with a single seed (often from a BIP39 mnemonic). \u2022 From that seed, it deterministically derives a master keypair (private + public key). \u2022 You can derive child keypairs from the master, and children of those, forming a tree structure. Key features: \u2022 One backup = all keys: Backing up the seed gives access to all derived keys. \u2022 Key separation: You can derive independent identities (child keys) without compromising the master. \u2022 Public derivation: Given a parent public key, you can derive child public keys (but not private keys). \u2022 Hardened derivation: A safer variant where child keys can\u2019t be derived from public keys, but requires the parent private key.","title":"1.1 BIP32"},{"location":"concepts/#12-bip39","text":"BIP39 (Bitcoin Improvement Proposal 39) defines a way to represent a deterministic wallet\u2019s private key using a human-readable set of words, called a mnemonic phrase. How it works: \u2022 A cryptographically strong random number (entropy) is generated. \u2022 That number is converted into a sequence of 12\u201324 words chosen from a predefined list of 2048 words. \u2022 This phrase can be used to derive a seed, which in turn can generate a hierarchy of keys (e.g., via BIP32). Key properties: \u2022 Mnemonic = backup: If you lose your device, you can recover your entire wallet using the phrase. \u2022 Language-agnostic: Wordlists exist for multiple languages. \u2022 Deterministic: The same phrase will always regenerate the same wallet.","title":"1.2 BIP39"},{"location":"concepts/#2-self-sovereign-identity","text":"Self-Sovereign Identity (SSI) is a Decentralised identity model where individuals control their own digital identities without relying on central authorities. The main issue which the concept SSI usually tends to ignore is 'truth'. As long an individual is in complete control of their own digital identity, who is to say this individual is not impersonating some other individual, or worse, conjuring up a completely new non-existing one. Cryptography can verify who issued a claim and whether it was tampered with, but it cannot verify the truthfulness of the claim itself. The validity of claims like a name, nationality, or birthdate ultimately depends on who the issuer is and whether they are trusted. However, since this requires authorities to be fully aligned with Web3 standards, we hit a dead end. Currently, most (if not all) authorities don't have any way to issue DIDs. So what DoaToa does, is reversing the flow yet again: an individual can create their own DID along with the related cryptographic keys. Which is actually in line with the entire idea of decentralisation. But 'claims' an individual makes are divided into 2 categories: formal and informal.","title":"2. Self-Sovereign-Identity"},{"location":"concepts/#21-did","text":"Decentralised IDentifier. A DID is a globally unique identifier that is not controlled by a central authority. Unlike traditional identifiers (usernames, emails, etc.), a DID is linked to a cryptographic keypair, allowing users to prove ownership without relying on a centralised system. A DID follows this format: did:<method>:<identifier> In DoaToa, primarily the 'key' method is used. This means that each 'identifier' part is actually the public part of a specific cryptographic public/private keypair. Each user is responsible for their own private key, which is used to sign data. The public key can always be used to verify the signature. The 'key' method also means there is no real need for a DID document, which is part of the DID spec.","title":"2.1 DID"},{"location":"concepts/#22-informal-claims","text":"Informal claims can be made within certain scopes, where the user provides their own data along with their signature. By nature, these claims cannot be verified by an authority. However, other identities can attest to a claim by signing it, effectively endorsing its validity. This attestation carries moral responsibility, as the signer\u2019s DID and signature become publicly associated with the claim.","title":"2.2 Informal Claims"},{"location":"concepts/#23-formal-claims","text":"Formal claims cannot be self-issued; they must come from a recognized authority. At this point in time, the only formal claims available to a DoaToa user, are the ones coming from their passport. These can be used to chain other claims of course: by taking your full name and birthdate, you can match then with the names and birthdate written on an official diploma. This functionality is out of scope for now.","title":"2.3 Formal Claims"},{"location":"concepts/#3-european-e-passports","text":"A European e-passport relies on a set of international standards to prove its authenticity and integrity using cryptographic techniques. These standards work together to ensure the data on the passport is both verifiable and resistant to tampering or cloning.","title":"3. European e-Passports"},{"location":"concepts/#31-icao-doc-9303","text":"The foundational specification for Machine Readable Travel Documents (MRTDs). It defines: The structure and contents of the e-passport chip. Cryptographic protocols such as: Passive Authentication (PA): Verifies the integrity and authenticity of the stored data using digital signatures from the issuing authority. Active Authentication (AA): Ensures the chip hasn\u2019t been cloned by using a private key challenge/response protocol.","title":"3.1 ICAO Doc 9303"},{"location":"concepts/#32-isoiec-7816-parts-4-8-9","text":"Standards for electronic identification cards with contacts, adapted for contactless chips in e-passports: Part 4: File system structure and command set (APDUs). Part 8: Security-related functions including authentication. Part 9: Access control and secure messaging. These standards allow secure and standardized access to the data groups (DG1\u2013DG15) on the chip.","title":"3.2 ISO/IEC 7816 (Parts 4, 8, 9)"},{"location":"concepts/#33-isoiec-14443-parts-14","text":"Defines the physical and communication characteristics for contactless smartcards: Enables NFC communication between passport chips and readers. Standard across all ICAO-compliant e-passports.","title":"3.3 ISO/IEC 14443 (Parts 1\u20134)"},{"location":"concepts/#34-isoiec-7501-1","text":"Specifies the physical format and layout of machine-readable passports, including: Dimensions Data placement The Machine Readable Zone (MRZ), which is used to derive keys for secure access (e.g., Basic Access Control).","title":"3.4 ISO/IEC 7501-1"},{"location":"concepts/#35-csca-and-dsc-certificates","text":"Each country operates a Country Signing Certificate Authority (CSCA) and issues Document Signer Certificates ( DSCs) : The CSCA\u2019s public key is distributed globally. The DSC signs the data on each passport. Verifiers use the CSCA chain to validate the DSC signature and ensure the data\u2019s authenticity. Together, these standards form the cryptographic backbone that allows e-passports to be trusted across borders.","title":"3.5 CSCA and DSC Certificates"},{"location":"concepts/#4-webrtc","text":"WebRTC (Web Real-Time Communication) is an open-source project and API standard that enables peer-to-peer communication directly between browsers or mobile apps, without requiring intermediate servers for media routing.","title":"4. WebRTC"},{"location":"concepts/#41-key-features","text":"Real-time audio and video streaming. Data channels for arbitrary peer-to-peer data transfer. Low latency , ideal for voice/video calls, gaming, and file sharing.","title":"4.1 Key Features"},{"location":"concepts/#42-how-it-works","text":"Signaling (out of scope for the WebRTC-spec): Exchanging connection info (e.g., IPs, codecs) between peers using a separate method (like WebSocket). ICE (Interactive Connectivity Establishment): Finds the best path through NATs/firewalls. DTLS/SRTP: Ensures encryption and secure transport . STUN/TURN servers: Help peers connect when direct connections are blocked. WebRTC is supported by all major browsers and is a core building block for modern real-time web applications.","title":"4.2 How It Works"},{"location":"concepts/#5-ucan-user-controlled-authorization-networks","text":"To align with Web3 standards, DoaToa has adopted UCAN. UCAN challenges the traditional client-server model, shifting control to the client. Clients generate their own JWTs, specifying the request and resource they intend to access. Each JWT is signed with the user\u2019s private key, allowing the server to verify the signature and determine whether access should be granted. This essentially reverses the OAuth 2.0 flow, where clients request a server-issued JWT with specific scopes. It should be noted that UCAN was originally designed for \"delegated authorization\". Meaning, an issuer creates a token that allows the bearer of the token to perform certain actions on certain resources. For authentication, an addition is required.","title":"5. UCAN - User Controlled Authorization Networks"},{"location":"concepts/#51-ucan-connect","text":"Like Open ID Connect adds an identification layer to OAuth2, UCAN Connect also adds an identification layer to UCAN. By embedding (verified) claims within UCAN JWTs, authentication systems eliminate the need to store user data, further decentralizing trust. The receiver of the token notifies the issuer of the token which scope(s) they would like to receive, and the issuer adds the related claims to the token. The receiver also should specify where the JWT should be sent.","title":"5.1 'UCAN Connect'"},{"location":"concepts/#52-implementation-of-the-ucan-connect-flow","text":"So how would all of this work in a real-world example? Let's set up a scenario. We start with three parties: Party A. The owner of the identity, aka the issuer of the UCAN token. Party B. The id-wallet of the owner (like DoaToa). Party C. A website, let's say a webshop called \"foo-bar.baz\". Party D. The server of \"foo-bar.baz\". Pre-requisite: both Party A/B, and Party C/D have a DID, signed by DoaToa. For a non-natural person, this means a DID from someone inside the legal entity, willing to represent the legal entity. Typically, A will visit C, which at some point requires A to identify themselves (to complete an order, for example). Party C has to create a scannable image (like a QR-code), which provides Party B all necessary information to authenticate Party A: The DID of Party C. The scopes of Party A that Party C requires. A connection proposal. Containing either a channel id - used to set up a WebRTC channel, or an authentication endpoint (Party D) - to which the token should be sent. This payload MUST be a multibase-encoded JSON message: { \"requestor\": \"did:key:a1b2c3d4e5f6g7h8ij9k0\", \"scopes\": [ \"did\", \"private-address\" ], \"destination\": { \"channelId\": \"someId\", \"authenticationEndpoint\": \"someEndpoint\" } }","title":"5.2 Implementation of the UCAN Connect flow"},{"location":"concepts/#6-authentication-through-webrtc","text":"Party D SHOULD initiate the WebRTC connection using the specified channel id. Party C is also allowed to do so, but that would expose the UCAN token to Party C, which is less secure. Party B will do so some seconds after scanning the payload. After the connection is set up, Party B will send the UCAN Connect token. Afterward, the connection is closed.","title":"6. Authentication through WebRTC"},{"location":"concepts/#61-authentication-through-an-endpoint","text":"The Party D connection endpoint MUST have the same domain as that of Party C. A subdomain is allowed. The connection endpoint MUST be as follows: ```http request POST /ucan-connect/auth HTTP/2 Authorization: \"Bearer ${theUCANConnectToken}\" (no body should be provided) ``` This endpoint MUST respond with either a 200 OK or a 401 UNAUTHENTICATED 200 OK: the tokens' signature matches the provided DID 401 UNAUTHENTICATED: the tokens' signature does not match the provided DID. The DID will be in the 'claims' array of the UCAN token. Or the DID does not match the specified public key. Then Party D SHOULD provide Party C with another token, specific for the current context, so Party C doesn't need to know anything about Party A.","title":"6.1 Authentication through an endpoint"},{"location":"concepts/#62-delegated-signing-using-ucan","text":"By creating a dedicated, short-lived and identity-bound token (by setting receivers' DID as the audience of the token), a user can delegate signing authority towards another entity, like the website they are currently on. The UCAN token is then embedded in the signature JWT in the prf-array. This is relevant if the user is adding content to the website and the website wants to have this content bound to a DID. The implications are that all content on the internet HAS to be tied to an author, producer, etc. Which means that fraudulent content, like non-consensual, AI-generated media, will have to signed as well.","title":"6.2 Delegated signing using UCAN"},{"location":"concepts/#7-cryptography","text":"Achieving true decentralization requires users to handle complex cryptographic operations. To make this accessible, all cryptographic functionality should be encapsulated within a user-friendly interface \u2014 a \u2018wallet\u2019. This wallet contains at least one cryptographic keypair: A root AES key for encrypting and decrypting the user\u2019s data. An EC-based public/private key pair for signing and verifying data. These algorithms are widely recognized standards, so I won\u2019t delve into their inner workings\u2014Wikipedia is your friend for that. With these keys, users can encrypt, decrypt, sign, and verify data entirely on the client side, ensuring full control over their information. In the subscription system, an additional key pair is introduced. This keypair facilitates sharing a derived AES key\u2014not the root AES key, but a deterministically generated AES key unique to each subscription.","title":"7. Cryptography"},{"location":"concepts/#71-post-quantum-disclaimer","text":"With the inevitable advent of quantum computing, these algorithms will change eventually. Currently, there are several candidates which could potentially take over the aforementioned algorithms. DoaToa will adapt accordingly. The biggest concern lies in asymmetric encryption, which is used for signing and sharing of secrets. Through Shor's algorithm, the asymmetric encryption algorithms we currently rely on will be cracked, meaning that private keys can be derived based on public keys. This is why everything related to asymmetric encryption should have an expiration time. And this is also part of the design of DoaToa: most data stays client-side.","title":"7.1 Post-Quantum disclaimer"},{"location":"concepts/#8-ipfs","text":"IPFS (InterPlanetary File System) is a peer-to-peer distributed file system that aims to make the web more * Decentralised , resilient , and permanent *. Traditionally, large tech companies have been responsible for storing data. This centralised model comes with several drawbacks, including single points of failure, high costs, and control over access to information. Decentralised storage offers an alternative by distributing data across multiple nodes instead of relying on a central server. This approach provides several advantages: Eliminates Single Points of Failure \u2013 No central server means no single point of failure, reducing the risk of data loss or downtime. Censorship Resistance \u2013 Data isn\u2019t controlled by a single entity, making it harder for governments or organizations to censor or remove information. Improved Availability \u2013 Multiple copies of data are stored across a network, ensuring accessibility even if some nodes go offline. Lower Costs \u2013 Users can share and utilize spare storage from others, reducing infrastructure costs compared to traditional cloud providers. Tamper Resistance \u2013 Cryptographic hashing and content addressing ensure data integrity and prevent unauthorized modifications. Trustless Environment \u2013 No need to rely on a central authority; cryptographic verification ensures data is stored and retrieved correctly. For DoaToa, a peer-to-peer approach aligns best with its principles. The InterPlanetary File System (IPFS) is a Decentralised, peer-to-peer protocol for storing and sharing data. Unlike traditional location-based addressing (where URLs point to specific servers), IPFS uses content addressing, identifying files by their cryptographic hash (CID).","title":"8. IPFS"},{"location":"concepts/#81-key-features-of-ipfs","text":"Content Addressing \u2013 Files are identified by unique hashes, ensuring integrity and deduplication. Peer-to-Peer Distribution \u2013 Files are retrieved from multiple nodes rather than a central server. Versioning \u2013 IPFS can track changes, similar to Git. Caching \u2013 Popular content is cached across the network for faster access. Interoperability \u2013 Works well with blockchain and Decentralised applications (dApps).","title":"8.1 Key Features of IPFS:"},{"location":"concepts/#82-problems-ipfs-solves","text":"Redundancy & Availability \u2013 Data remains accessible without reliance on a single server. Censorship Resistance \u2013 Information remains online as long as at least one node hosts it. Efficient Content Delivery \u2013 Data is retrieved from the nearest available node, reducing latency. However, IPFS alone does not guarantee permanent storage\u2014data can disappear if no node continues to host it. To ensure persistence, data must be pinned. This can be done either manually (free) or through a pinning service. Currently, DoaToa uses a pinning service, but in the future, your wallet will evolve to support self-hosting and pinning, ensuring full control over data storage","title":"8.2 Problems IPFS Solves:"},{"location":"concepts/#9-multibase-encoding","text":"On the internet, a lot of raw data (bytes) is transported using something called base encoding. These encodings essentially turn the raw bytes into a piece of transportable and near-readable text. But when you wish to access the raw bytes again on the receiving side, you need to know which encoding was used in order to decode it. But there are a lot of different encodings to choose from. This means that encoding and decoding must be well-documented. With Multibase encoding, a special reserved character for each specific encoding is appended to the encoded value which indicates which encoding was used. This means that anyone receiving the encoded bytes can always decode it. More can be read here .","title":"9. Multibase Encoding"},{"location":"concepts/authority-in-decentralised-systems/","text":"Authorities in Decentralised Identity Systems It might seem counter-intuitive, why would there be a need for a trusted centralised party in a Decentralised identity system? This is simply because identity is non-deterministic. It is a social construct that is solely based on trust. At birth, you have to trust that your parents/guardians take care to perform the correct steps to register you. During your life you have to trust the authorities to take care of this identity, especially in the area of security. Given an ever-changing world (consider the digital revolution), this is a huge undertaking. In a Decentralised identity system, everybody is equal, as is their ability to make claims about themselves. By introducing a central authority, everybody can agree that their judgment is the correct one.","title":"Authorities in Decentralised Identity Systems"},{"location":"concepts/authority-in-decentralised-systems/#authorities-in-decentralised-identity-systems","text":"It might seem counter-intuitive, why would there be a need for a trusted centralised party in a Decentralised identity system? This is simply because identity is non-deterministic. It is a social construct that is solely based on trust. At birth, you have to trust that your parents/guardians take care to perform the correct steps to register you. During your life you have to trust the authorities to take care of this identity, especially in the area of security. Given an ever-changing world (consider the digital revolution), this is a huge undertaking. In a Decentralised identity system, everybody is equal, as is their ability to make claims about themselves. By introducing a central authority, everybody can agree that their judgment is the correct one.","title":"Authorities in Decentralised Identity Systems"},{"location":"concepts/bip32/","text":"BIP32 BIP32 (Bitcoin Improvement Proposal 32) defines Hierarchical Deterministic (HD) wallets, which allow you to derive a tree of keypairs from a single root seed. How it works: \u2022 Starts with a single seed (often from a BIP39 mnemonic). \u2022 From that seed, it deterministically derives a master keypair (private + public key). \u2022 You can derive child keypairs from the master, and children of those, forming a tree structure. Key features: \u2022 One backup = all keys: Backing up the seed gives access to all derived keys. \u2022 Key separation: You can derive independent identities (child keys) without compromising the master. \u2022 Public derivation: Given a parent public key, you can derive child public keys (but not private keys). \u2022 Hardened derivation: A safer variant where child keys can\u2019t be derived from public keys, but requires the parent private key.","title":"BIP32"},{"location":"concepts/bip32/#bip32","text":"BIP32 (Bitcoin Improvement Proposal 32) defines Hierarchical Deterministic (HD) wallets, which allow you to derive a tree of keypairs from a single root seed. How it works: \u2022 Starts with a single seed (often from a BIP39 mnemonic). \u2022 From that seed, it deterministically derives a master keypair (private + public key). \u2022 You can derive child keypairs from the master, and children of those, forming a tree structure. Key features: \u2022 One backup = all keys: Backing up the seed gives access to all derived keys. \u2022 Key separation: You can derive independent identities (child keys) without compromising the master. \u2022 Public derivation: Given a parent public key, you can derive child public keys (but not private keys). \u2022 Hardened derivation: A safer variant where child keys can\u2019t be derived from public keys, but requires the parent private key.","title":"BIP32"},{"location":"concepts/bip39/","text":"BIP39 BIP39 (Bitcoin Improvement Proposal 39) defines a way to represent a deterministic wallet\u2019s private key using a human-readable set of words, called a mnemonic phrase. How it works: \u2022 A cryptographically strong random number (entropy) is generated. \u2022 That number is converted into a sequence of 12\u201324 words chosen from a predefined list of 2048 words. \u2022 This phrase can be used to derive a seed, which in turn can generate a hierarchy of keys (e.g., via BIP32). Key properties: \u2022 Mnemonic = backup: If you lose your device, you can recover your entire wallet using the phrase. \u2022 Language-agnostic: Wordlists exist for multiple languages. \u2022 Deterministic: The same phrase will always regenerate the same wallet.","title":"BIP39"},{"location":"concepts/bip39/#bip39","text":"BIP39 (Bitcoin Improvement Proposal 39) defines a way to represent a deterministic wallet\u2019s private key using a human-readable set of words, called a mnemonic phrase. How it works: \u2022 A cryptographically strong random number (entropy) is generated. \u2022 That number is converted into a sequence of 12\u201324 words chosen from a predefined list of 2048 words. \u2022 This phrase can be used to derive a seed, which in turn can generate a hierarchy of keys (e.g., via BIP32). Key properties: \u2022 Mnemonic = backup: If you lose your device, you can recover your entire wallet using the phrase. \u2022 Language-agnostic: Wordlists exist for multiple languages. \u2022 Deterministic: The same phrase will always regenerate the same wallet.","title":"BIP39"},{"location":"concepts/cryptography/","text":"Cryptography Achieving true decentralization requires users to handle complex cryptographic operations. To make this accessible, all cryptographic functionality should be encapsulated within a user-friendly interface \u2014 a \u2018wallet\u2019. This wallet contains at least one cryptographic keypair: A root AES key for encrypting and decrypting the user\u2019s data. An EC-based public/private key pair for signing and verifying data. These algorithms are widely recognized standards, so I won\u2019t delve into their inner workings\u2014Wikipedia is your friend for that. With these keys, users can encrypt, decrypt, sign, and verify data entirely on the client side, ensuring full control over their information. In the subscription system, an additional key pair is introduced. This keypair facilitates sharing a derived AES key\u2014not the root AES key, but a deterministically generated AES key unique to each subscription. Post-Quantum disclaimer With the inevitable advent of quantum computing, these algorithms will change eventually. Currently, there are several candidates which could potentially take over the aforementioned algorithms. DoaToa will adapt accordingly. The biggest concern lies in asymmetric encryption, which is used for signing and sharing of secrets. Through Shor's algorithm, the asymmetric encryption algorithms we currently rely on will be cracked, meaning that private keys can be derived based on public keys. This is why everything related to asymmetric encryption should have an expiration time. And this is also part of the design of DoaToa: most data stays client-side.","title":"Cryptography"},{"location":"concepts/cryptography/#cryptography","text":"Achieving true decentralization requires users to handle complex cryptographic operations. To make this accessible, all cryptographic functionality should be encapsulated within a user-friendly interface \u2014 a \u2018wallet\u2019. This wallet contains at least one cryptographic keypair: A root AES key for encrypting and decrypting the user\u2019s data. An EC-based public/private key pair for signing and verifying data. These algorithms are widely recognized standards, so I won\u2019t delve into their inner workings\u2014Wikipedia is your friend for that. With these keys, users can encrypt, decrypt, sign, and verify data entirely on the client side, ensuring full control over their information. In the subscription system, an additional key pair is introduced. This keypair facilitates sharing a derived AES key\u2014not the root AES key, but a deterministically generated AES key unique to each subscription.","title":"Cryptography"},{"location":"concepts/cryptography/#post-quantum-disclaimer","text":"With the inevitable advent of quantum computing, these algorithms will change eventually. Currently, there are several candidates which could potentially take over the aforementioned algorithms. DoaToa will adapt accordingly. The biggest concern lies in asymmetric encryption, which is used for signing and sharing of secrets. Through Shor's algorithm, the asymmetric encryption algorithms we currently rely on will be cracked, meaning that private keys can be derived based on public keys. This is why everything related to asymmetric encryption should have an expiration time. And this is also part of the design of DoaToa: most data stays client-side.","title":"Post-Quantum disclaimer"},{"location":"concepts/did/","text":"DID Decentralised IDentifier. A DID is a globally unique identifier that is not controlled by a central authority. Unlike traditional identifiers (usernames, emails, etc.), a DID is linked to a cryptographic keypair, allowing users to prove ownership without relying on a centralised system. A DID follows this format: did:<method>:<identifier> In DoaToa, primarily the 'key' method is used. This means that each 'identifier' part is actually the public part of a specific cryptographic public/private keypair. Each user is responsible for their own private key, which is used to sign data. The public key can always be used to verify the signature. The 'key' method also means there is no real need for a DID document, which is part of the DID spec.","title":"DID"},{"location":"concepts/did/#did","text":"Decentralised IDentifier. A DID is a globally unique identifier that is not controlled by a central authority. Unlike traditional identifiers (usernames, emails, etc.), a DID is linked to a cryptographic keypair, allowing users to prove ownership without relying on a centralised system. A DID follows this format: did:<method>:<identifier> In DoaToa, primarily the 'key' method is used. This means that each 'identifier' part is actually the public part of a specific cryptographic public/private keypair. Each user is responsible for their own private key, which is used to sign data. The public key can always be used to verify the signature. The 'key' method also means there is no real need for a DID document, which is part of the DID spec.","title":"DID"},{"location":"concepts/ipfs/","text":"IPFS IPFS (InterPlanetary File System) is a peer-to-peer distributed file system that aims to make the web more Decentralised , resilient , and permanent . Decentralised Storage Traditionally, large tech companies have been responsible for storing data. This centralised model comes with several drawbacks, including single points of failure, high costs, and control over access to information. Decentralised storage offers an alternative by distributing data across multiple nodes instead of relying on a central server. This approach provides several advantages: - Eliminates Single Points of Failure \u2013 No central server means no single point of failure, reducing the risk of data loss or downtime. - Censorship Resistance \u2013 Data isn\u2019t controlled by a single entity, making it harder for governments or organizations to censor or remove information. - Improved Availability \u2013 Multiple copies of data are stored across a network, ensuring accessibility even if some nodes go offline. - Lower Costs \u2013 Users can share and utilize spare storage from others, reducing infrastructure costs compared to traditional cloud providers. - Tamper Resistance \u2013 Cryptographic hashing and content addressing ensure data integrity and prevent unauthorized modifications. - Trustless Environment \u2013 No need to rely on a central authority; cryptographic verification ensures data is stored and retrieved correctly. Decentralised Storage in DoaToa For DoaToa, a peer-to-peer approach aligns best with its principles. The InterPlanetary File System (IPFS) is a Decentralised, peer-to-peer protocol for storing and sharing data. Unlike traditional location-based addressing (where URLs point to specific servers), IPFS uses content addressing, identifying files by their cryptographic hash (CID). Key Features of IPFS: Content Addressing \u2013 Files are identified by unique hashes, ensuring integrity and deduplication. Peer-to-Peer Distribution \u2013 Files are retrieved from multiple nodes rather than a central server. Versioning \u2013 IPFS can track changes, similar to Git. Caching \u2013 Popular content is cached across the network for faster access. Interoperability \u2013 Works well with blockchain and Decentralised applications (dApps). Problems IPFS Solves: Redundancy & Availability \u2013 Data remains accessible without reliance on a single server. Censorship Resistance \u2013 Information remains online as long as at least one node hosts it. Efficient Content Delivery \u2013 Data is retrieved from the nearest available node, reducing latency. However, IPFS alone does not guarantee permanent storage\u2014data can disappear if no node continues to host it. To ensure persistence, data must be pinned. This can be done either manually (free) or through a pinning service. Currently, DoaToa uses a pinning service, but in the future, your wallet will evolve to support self-hosting and pinning, ensuring full control over data storage Key Features Content-addressed: Files are identified by their cryptographic hash , not by location (like a URL). Distributed storage: Files are shared and stored across a network of peers. Versioned: Supports version control and immutable data structures (like Git). Offline-friendly: Data can be accessed locally without needing a central server. How It Works A file is added to IPFS and broken into chunks. Each chunk is hashed and stored in a Merkle DAG . The root hash (CID - Content Identifier) acts as the address for the entire file. Anyone with the CID can fetch the file from any peer who has it. Common Use Cases Decentralised websites (often with IPNS or ENS) Content archiving and permanence Peer-to-peer file sharing Blockchain data storage (e.g., NFTs) IPFS is often used with pinning services or local nodes to ensure data availability.","title":"IPFS"},{"location":"concepts/ipfs/#ipfs","text":"IPFS (InterPlanetary File System) is a peer-to-peer distributed file system that aims to make the web more Decentralised , resilient , and permanent .","title":"IPFS"},{"location":"concepts/ipfs/#decentralised-storage","text":"Traditionally, large tech companies have been responsible for storing data. This centralised model comes with several drawbacks, including single points of failure, high costs, and control over access to information. Decentralised storage offers an alternative by distributing data across multiple nodes instead of relying on a central server. This approach provides several advantages: - Eliminates Single Points of Failure \u2013 No central server means no single point of failure, reducing the risk of data loss or downtime. - Censorship Resistance \u2013 Data isn\u2019t controlled by a single entity, making it harder for governments or organizations to censor or remove information. - Improved Availability \u2013 Multiple copies of data are stored across a network, ensuring accessibility even if some nodes go offline. - Lower Costs \u2013 Users can share and utilize spare storage from others, reducing infrastructure costs compared to traditional cloud providers. - Tamper Resistance \u2013 Cryptographic hashing and content addressing ensure data integrity and prevent unauthorized modifications. - Trustless Environment \u2013 No need to rely on a central authority; cryptographic verification ensures data is stored and retrieved correctly.","title":"Decentralised Storage"},{"location":"concepts/ipfs/#decentralised-storage-in-doatoa","text":"For DoaToa, a peer-to-peer approach aligns best with its principles. The InterPlanetary File System (IPFS) is a Decentralised, peer-to-peer protocol for storing and sharing data. Unlike traditional location-based addressing (where URLs point to specific servers), IPFS uses content addressing, identifying files by their cryptographic hash (CID).","title":"Decentralised Storage in DoaToa"},{"location":"concepts/ipfs/#key-features-of-ipfs","text":"Content Addressing \u2013 Files are identified by unique hashes, ensuring integrity and deduplication. Peer-to-Peer Distribution \u2013 Files are retrieved from multiple nodes rather than a central server. Versioning \u2013 IPFS can track changes, similar to Git. Caching \u2013 Popular content is cached across the network for faster access. Interoperability \u2013 Works well with blockchain and Decentralised applications (dApps).","title":"Key Features of IPFS:"},{"location":"concepts/ipfs/#problems-ipfs-solves","text":"Redundancy & Availability \u2013 Data remains accessible without reliance on a single server. Censorship Resistance \u2013 Information remains online as long as at least one node hosts it. Efficient Content Delivery \u2013 Data is retrieved from the nearest available node, reducing latency. However, IPFS alone does not guarantee permanent storage\u2014data can disappear if no node continues to host it. To ensure persistence, data must be pinned. This can be done either manually (free) or through a pinning service. Currently, DoaToa uses a pinning service, but in the future, your wallet will evolve to support self-hosting and pinning, ensuring full control over data storage","title":"Problems IPFS Solves:"},{"location":"concepts/ipfs/#key-features","text":"Content-addressed: Files are identified by their cryptographic hash , not by location (like a URL). Distributed storage: Files are shared and stored across a network of peers. Versioned: Supports version control and immutable data structures (like Git). Offline-friendly: Data can be accessed locally without needing a central server.","title":"Key Features"},{"location":"concepts/ipfs/#how-it-works","text":"A file is added to IPFS and broken into chunks. Each chunk is hashed and stored in a Merkle DAG . The root hash (CID - Content Identifier) acts as the address for the entire file. Anyone with the CID can fetch the file from any peer who has it.","title":"How It Works"},{"location":"concepts/ipfs/#common-use-cases","text":"Decentralised websites (often with IPNS or ENS) Content archiving and permanence Peer-to-peer file sharing Blockchain data storage (e.g., NFTs) IPFS is often used with pinning services or local nodes to ensure data availability.","title":"Common Use Cases"},{"location":"concepts/multibase-encoding/","text":"Multibase Encoding On the internet, a lot of raw data (bytes) is transported using something called base encoding. These encodings essentially turn the raw bytes into a piece of transportable and near-readable text. But when you wish to access the raw bytes again on the receiving side, you need to know which encoding was used in order to decode it. But there are a lot of different encodings to choose from. This means that encoding and decoding must be well-documented. With Multibase encoding, a special reserved character for each specific encoding is appended to the encoded value which indicates which encoding was used. This means that anyone receiving the encoded bytes can always decode it. More can be read here .","title":"Multibase Encoding"},{"location":"concepts/multibase-encoding/#multibase-encoding","text":"On the internet, a lot of raw data (bytes) is transported using something called base encoding. These encodings essentially turn the raw bytes into a piece of transportable and near-readable text. But when you wish to access the raw bytes again on the receiving side, you need to know which encoding was used in order to decode it. But there are a lot of different encodings to choose from. This means that encoding and decoding must be well-documented. With Multibase encoding, a special reserved character for each specific encoding is appended to the encoded value which indicates which encoding was used. This means that anyone receiving the encoded bytes can always decode it. More can be read here .","title":"Multibase Encoding"},{"location":"concepts/self-sovereign-identity/","text":"Self-Sovereign-Identity Self-Sovereign Identity (SSI) is a Decentralised identity model where individuals control their own digital identities without relying on central authorities. The main issue which the concept SSI usually tends to ignore is 'truth'. As long an individual is in complete control of their own digital identity, who is to say this individual is not impersonating some other individual, or worse, conjuring up a completely new non-existing one. Cryptography can verify who issued a claim and whether it was tampered with, but it cannot verify the truthfulness of the claim itself. The validity of claims like a name, nationality, or birthdate ultimately depends on who the issuer is and whether they are trusted. However, since this requires authorities to be fully aligned with Web3 standards, we hit a dead end. Currently, most (if not all) authorities don't have any way to issue DIDs. So what DoaToa does, is reversing the flow yet again: an individual can create their own DID along with the related cryptographic keys. Which is actually in line with the entire idea of decentralisation. But 'claims' an individual makes are divided into 2 categories: formal and informal. Informal Claims Informal claims can be made within certain scopes, where the user provides their own data along with their signature. By nature, these claims cannot be verified by an authority. However, other identities can attest to a claim by signing it, effectively endorsing its validity. This attestation carries moral responsibility, as the signer\u2019s DID and signature become publicly associated with the claim. Formal Claims Formal claims cannot be self-issued; they must come from a recognized authority. At this point in time, the only formal claims available to a DoaToa user, are the ones coming from their passport. These can be used to chain other claims of course: by taking your full name and birthdate, you can match then with the names and birthdate written on an official diploma. This functionality is out of scope for now.","title":"Self-Sovereign-Identity"},{"location":"concepts/self-sovereign-identity/#self-sovereign-identity","text":"Self-Sovereign Identity (SSI) is a Decentralised identity model where individuals control their own digital identities without relying on central authorities. The main issue which the concept SSI usually tends to ignore is 'truth'. As long an individual is in complete control of their own digital identity, who is to say this individual is not impersonating some other individual, or worse, conjuring up a completely new non-existing one. Cryptography can verify who issued a claim and whether it was tampered with, but it cannot verify the truthfulness of the claim itself. The validity of claims like a name, nationality, or birthdate ultimately depends on who the issuer is and whether they are trusted. However, since this requires authorities to be fully aligned with Web3 standards, we hit a dead end. Currently, most (if not all) authorities don't have any way to issue DIDs. So what DoaToa does, is reversing the flow yet again: an individual can create their own DID along with the related cryptographic keys. Which is actually in line with the entire idea of decentralisation. But 'claims' an individual makes are divided into 2 categories: formal and informal.","title":"Self-Sovereign-Identity"},{"location":"concepts/self-sovereign-identity/#informal-claims","text":"Informal claims can be made within certain scopes, where the user provides their own data along with their signature. By nature, these claims cannot be verified by an authority. However, other identities can attest to a claim by signing it, effectively endorsing its validity. This attestation carries moral responsibility, as the signer\u2019s DID and signature become publicly associated with the claim.","title":"Informal Claims"},{"location":"concepts/self-sovereign-identity/#formal-claims","text":"Formal claims cannot be self-issued; they must come from a recognized authority. At this point in time, the only formal claims available to a DoaToa user, are the ones coming from their passport. These can be used to chain other claims of course: by taking your full name and birthdate, you can match then with the names and birthdate written on an official diploma. This functionality is out of scope for now.","title":"Formal Claims"},{"location":"concepts/standardised-e-passports/","text":"Cryptographic Standards Enabling European e-Passport Integrity A European e-passport relies on a set of international standards to prove its authenticity and integrity using cryptographic techniques. These standards work together to ensure the data on the passport is both verifiable and resistant to tampering or cloning. ICAO Doc 9303 The foundational specification for Machine Readable Travel Documents (MRTDs). It defines: The structure and contents of the e-passport chip. Cryptographic protocols such as: Passive Authentication (PA): Verifies the integrity and authenticity of the stored data using digital signatures from the issuing authority. Active Authentication (AA): Ensures the chip hasn\u2019t been cloned by using a private key challenge/response protocol. ISO/IEC 7816 (Parts 4, 8, 9) Standards for electronic identification cards with contacts, adapted for contactless chips in e-passports: Part 4: File system structure and command set (APDUs). Part 8: Security-related functions including authentication. Part 9: Access control and secure messaging. These standards allow secure and standardized access to the data groups (DG1\u2013DG15) on the chip. ISO/IEC 14443 (Parts 1\u20134) Defines the physical and communication characteristics for contactless smartcards: Enables NFC communication between passport chips and readers. Standard across all ICAO-compliant e-passports. ISO/IEC 7501-1 Specifies the physical format and layout of machine-readable passports, including: Dimensions Data placement The Machine Readable Zone (MRZ), which is used to derive keys for secure access (e.g., Basic Access Control). CSCA and DSC Certificates Each country operates a Country Signing Certificate Authority (CSCA) and issues Document Signer Certificates (DSCs) : The CSCA\u2019s public key is distributed globally. The DSC signs the data on each passport. Verifiers use the CSCA chain to validate the DSC signature and ensure the data\u2019s authenticity. Together, these standards form the cryptographic backbone that allows e-passports to be trusted across borders.","title":"Cryptographic Standards Enabling European e-Passport Integrity"},{"location":"concepts/standardised-e-passports/#cryptographic-standards-enabling-european-e-passport-integrity","text":"A European e-passport relies on a set of international standards to prove its authenticity and integrity using cryptographic techniques. These standards work together to ensure the data on the passport is both verifiable and resistant to tampering or cloning.","title":"Cryptographic Standards Enabling European e-Passport Integrity"},{"location":"concepts/standardised-e-passports/#icao-doc-9303","text":"The foundational specification for Machine Readable Travel Documents (MRTDs). It defines: The structure and contents of the e-passport chip. Cryptographic protocols such as: Passive Authentication (PA): Verifies the integrity and authenticity of the stored data using digital signatures from the issuing authority. Active Authentication (AA): Ensures the chip hasn\u2019t been cloned by using a private key challenge/response protocol.","title":"ICAO Doc 9303"},{"location":"concepts/standardised-e-passports/#isoiec-7816-parts-4-8-9","text":"Standards for electronic identification cards with contacts, adapted for contactless chips in e-passports: Part 4: File system structure and command set (APDUs). Part 8: Security-related functions including authentication. Part 9: Access control and secure messaging. These standards allow secure and standardized access to the data groups (DG1\u2013DG15) on the chip.","title":"ISO/IEC 7816 (Parts 4, 8, 9)"},{"location":"concepts/standardised-e-passports/#isoiec-14443-parts-14","text":"Defines the physical and communication characteristics for contactless smartcards: Enables NFC communication between passport chips and readers. Standard across all ICAO-compliant e-passports.","title":"ISO/IEC 14443 (Parts 1\u20134)"},{"location":"concepts/standardised-e-passports/#isoiec-7501-1","text":"Specifies the physical format and layout of machine-readable passports, including: Dimensions Data placement The Machine Readable Zone (MRZ), which is used to derive keys for secure access (e.g., Basic Access Control).","title":"ISO/IEC 7501-1"},{"location":"concepts/standardised-e-passports/#csca-and-dsc-certificates","text":"Each country operates a Country Signing Certificate Authority (CSCA) and issues Document Signer Certificates (DSCs) : The CSCA\u2019s public key is distributed globally. The DSC signs the data on each passport. Verifiers use the CSCA chain to validate the DSC signature and ensure the data\u2019s authenticity. Together, these standards form the cryptographic backbone that allows e-passports to be trusted across borders.","title":"CSCA and DSC Certificates"},{"location":"concepts/ucan/","text":"UCAN - User Controlled Authorization Networks To align with Web3 standards, DoaToa has adopted UCAN. UCAN challenges the traditional client-server model, shifting control to the client. Clients generate their own JWTs, specifying the request and resource they intend to access. Each JWT is signed with the user\u2019s private key, allowing the server to verify the signature and determine whether access should be granted. This essentially reverses the OAuth 2.0 flow, where clients request a server-issued JWT with specific scopes. It should be noted that UCAN was originally designed for \"delegated authorization\". Meaning, an issuer creates a token that allows the bearer of the token to perform certain actions on certain resources. For authentication, an addition is required. 'UCAN Connect' Like Open ID Connect adds an identification layer to OAuth2, UCAN Connect also adds an identification layer to UCAN. By embedding (verified) claims within UCAN JWTs, authentication systems eliminate the need to store user data, further decentralizing trust. The receiver of the token notifies the issuer of the token which scope(s) they would like to receive, and the issuer adds the related claims to the token. The receiver also should specify where the JWT should be sent. Implementation of the UCAN Connect flow So how would all of this work in a real-world example? Let's set up a scenario. We start with three parties: Party A. The owner of the identity, aka the issuer of the UCAN token. Party B. The id-wallet of the owner (like DoaToa). Party C. A website, let's say a webshop called \"foo-bar.baz\". Party D. The server of \"foo-bar.baz\". Pre-requisite: both Party A/B, and Party C/D have a DID, signed by DoaToa. For a non-natural person, this means a DID from someone inside the legal entity, willing to represent the legal entity. Typically, A will visit C, which at some point requires A to identify themselves (to complete an order, for example). Party C has to create a scannable image (like a QR-code), which provides Party B all necessary information to authenticate Party A: The DID of Party C. The scopes of Party A that Party C requires. A connection proposal. Containing either a channel id - used to set up a WebRTC channel, or an authentication endpoint (Party D) - to which the token should be sent. This payload MUST be a multibase-encoded JSON message: { \"requestor\": \"did:key:a1b2c3d4e5f6g7h8ij9k0\", \"scopes\": [ \"did\", \"private-address\" ], \"destination\": { \"channelId\": \"someId\", \"authenticationEndpoint\": \"someEndpoint\" } } Authentication through WebRTC Party D SHOULD initiate the WebRTC connection using the specified channel id. Party C is also allowed to do so, but that would expose the UCAN token to Party C, which is less secure. Party B will do so some seconds after scanning the payload. After the connection is set up, Party B will send the UCAN Connect token. Afterward, the connection is closed. Authentication through an endpoint The Party D connection endpoint MUST have the same domain as that of Party C. A subdomain is allowed. The connection endpoint MUST be as follows: ```http request POST /ucan-connect/auth HTTP/2 Authorization: \"Bearer ${theUCANConnectToken}\" (no body should be provided) ``` This endpoint MUST respond with either a 200 OK or a 401 UNAUTHENTICATED 200 OK: the tokens' signature matches the provided DID 401 UNAUTHENTICATED: the tokens' signature does not match the provided DID. The DID will be in the 'claims' array of the UCAN token. Or the DID does not match the specified public key. Then Party D SHOULD provide Party C with another token, specific for the current context, so Party C doesn't need to know anything about Party A. Delegated signing using UCAN By creating a dedicated, short-lived and identity-bound token (by setting receivers' DID as the audience of the token), a user can delegate signing authority towards another entity, like the website they are currently on. The UCAN token is then embedded in the signature JWT in the prf-array. This is relevant if the user is adding content to the website and the website wants to have this content bound to a DID. The implications are that all content on the internet HAS to be tied to an author, producer, etc. Which means that fraudulent content, like non-consensual, AI-generated media, will have to signed as well.","title":"UCAN - User Controlled Authorization Networks"},{"location":"concepts/ucan/#ucan-user-controlled-authorization-networks","text":"To align with Web3 standards, DoaToa has adopted UCAN. UCAN challenges the traditional client-server model, shifting control to the client. Clients generate their own JWTs, specifying the request and resource they intend to access. Each JWT is signed with the user\u2019s private key, allowing the server to verify the signature and determine whether access should be granted. This essentially reverses the OAuth 2.0 flow, where clients request a server-issued JWT with specific scopes. It should be noted that UCAN was originally designed for \"delegated authorization\". Meaning, an issuer creates a token that allows the bearer of the token to perform certain actions on certain resources. For authentication, an addition is required.","title":"UCAN - User Controlled Authorization Networks"},{"location":"concepts/ucan/#ucan-connect","text":"Like Open ID Connect adds an identification layer to OAuth2, UCAN Connect also adds an identification layer to UCAN. By embedding (verified) claims within UCAN JWTs, authentication systems eliminate the need to store user data, further decentralizing trust. The receiver of the token notifies the issuer of the token which scope(s) they would like to receive, and the issuer adds the related claims to the token. The receiver also should specify where the JWT should be sent.","title":"'UCAN Connect'"},{"location":"concepts/ucan/#implementation-of-the-ucan-connect-flow","text":"So how would all of this work in a real-world example? Let's set up a scenario. We start with three parties: Party A. The owner of the identity, aka the issuer of the UCAN token. Party B. The id-wallet of the owner (like DoaToa). Party C. A website, let's say a webshop called \"foo-bar.baz\". Party D. The server of \"foo-bar.baz\". Pre-requisite: both Party A/B, and Party C/D have a DID, signed by DoaToa. For a non-natural person, this means a DID from someone inside the legal entity, willing to represent the legal entity. Typically, A will visit C, which at some point requires A to identify themselves (to complete an order, for example). Party C has to create a scannable image (like a QR-code), which provides Party B all necessary information to authenticate Party A: The DID of Party C. The scopes of Party A that Party C requires. A connection proposal. Containing either a channel id - used to set up a WebRTC channel, or an authentication endpoint (Party D) - to which the token should be sent. This payload MUST be a multibase-encoded JSON message: { \"requestor\": \"did:key:a1b2c3d4e5f6g7h8ij9k0\", \"scopes\": [ \"did\", \"private-address\" ], \"destination\": { \"channelId\": \"someId\", \"authenticationEndpoint\": \"someEndpoint\" } }","title":"Implementation of the UCAN Connect flow"},{"location":"concepts/ucan/#authentication-through-webrtc","text":"Party D SHOULD initiate the WebRTC connection using the specified channel id. Party C is also allowed to do so, but that would expose the UCAN token to Party C, which is less secure. Party B will do so some seconds after scanning the payload. After the connection is set up, Party B will send the UCAN Connect token. Afterward, the connection is closed.","title":"Authentication through WebRTC"},{"location":"concepts/ucan/#authentication-through-an-endpoint","text":"The Party D connection endpoint MUST have the same domain as that of Party C. A subdomain is allowed. The connection endpoint MUST be as follows: ```http request POST /ucan-connect/auth HTTP/2 Authorization: \"Bearer ${theUCANConnectToken}\" (no body should be provided) ``` This endpoint MUST respond with either a 200 OK or a 401 UNAUTHENTICATED 200 OK: the tokens' signature matches the provided DID 401 UNAUTHENTICATED: the tokens' signature does not match the provided DID. The DID will be in the 'claims' array of the UCAN token. Or the DID does not match the specified public key. Then Party D SHOULD provide Party C with another token, specific for the current context, so Party C doesn't need to know anything about Party A.","title":"Authentication through an endpoint"},{"location":"concepts/ucan/#delegated-signing-using-ucan","text":"By creating a dedicated, short-lived and identity-bound token (by setting receivers' DID as the audience of the token), a user can delegate signing authority towards another entity, like the website they are currently on. The UCAN token is then embedded in the signature JWT in the prf-array. This is relevant if the user is adding content to the website and the website wants to have this content bound to a DID. The implications are that all content on the internet HAS to be tied to an author, producer, etc. Which means that fraudulent content, like non-consensual, AI-generated media, will have to signed as well.","title":"Delegated signing using UCAN"},{"location":"concepts/web-rtc/","text":"WebRTC WebRTC (Web Real-Time Communication) is an open-source project and API standard that enables peer-to-peer communication directly between browsers or mobile apps, without requiring intermediate servers for media routing. Key Features Real-time audio and video streaming. Data channels for arbitrary peer-to-peer data transfer. Low latency , ideal for voice/video calls, gaming, and file sharing. How It Works Signaling (out of scope for the WebRTC-spec): Exchanging connection info (e.g., IPs, codecs) between peers using a separate method (like WebSocket). ICE (Interactive Connectivity Establishment): Finds the best path through NATs/firewalls. DTLS/SRTP: Ensures encryption and secure transport . STUN/TURN servers: Help peers connect when direct connections are blocked. Common Use Cases Video conferencing Voice calls Screen sharing Real-time multiplayer games Decentralised applications WebRTC is supported by all major browsers and is a core building block for modern real-time web applications.","title":"WebRTC"},{"location":"concepts/web-rtc/#webrtc","text":"WebRTC (Web Real-Time Communication) is an open-source project and API standard that enables peer-to-peer communication directly between browsers or mobile apps, without requiring intermediate servers for media routing.","title":"WebRTC"},{"location":"concepts/web-rtc/#key-features","text":"Real-time audio and video streaming. Data channels for arbitrary peer-to-peer data transfer. Low latency , ideal for voice/video calls, gaming, and file sharing.","title":"Key Features"},{"location":"concepts/web-rtc/#how-it-works","text":"Signaling (out of scope for the WebRTC-spec): Exchanging connection info (e.g., IPs, codecs) between peers using a separate method (like WebSocket). ICE (Interactive Connectivity Establishment): Finds the best path through NATs/firewalls. DTLS/SRTP: Ensures encryption and secure transport . STUN/TURN servers: Help peers connect when direct connections are blocked.","title":"How It Works"},{"location":"concepts/web-rtc/#common-use-cases","text":"Video conferencing Voice calls Screen sharing Real-time multiplayer games Decentralised applications WebRTC is supported by all major browsers and is a core building block for modern real-time web applications.","title":"Common Use Cases"}]}